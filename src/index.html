<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crazy Balloon - クレイジーバルーン</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        #gameCanvas {
            border: 2px solid #444;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        #ui {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 14px;
        }
        
        .controls {
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            color: #888;
        }
        
        .debug {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 10px;
            color: #888;
            background: rgba(0,0,0,0.5);
            padding: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="300" height="256"></canvas>
    <div id="ui">
        <div>SCORE: <span id="score">0</span></div>
        <div>HI-SCORE: <span id="hiscore">0</span></div>
        <div>STAGE: <span id="stage">1</span></div>
        <div>LIVES: <span id="lives">3</span></div>
    </div>
    <div class="controls">
        Use Arrow Keys or WASD to control the red balloon<br>
        Moving expands the balloon, staying still shrinks it<br>
        Avoid touching the blue dots - Navigate to the green GOAL<br>
        Press SPACE to start
    </div>

    <div class="debug" id="debug">
        FPS: <span id="fps">60</span><br>
        State: <span id="gameState">TITLE</span><br>
        Player: <span id="playerPos">0,0</span>
    </div>
    
    <script>
        // ===== STAGE DATA (5 STAGES) =====
        const STAGES = [
            {   // Stage 3: Simple Maze (from map004.dat)
                id: 3,
                name: "Simple Maze",
                width: 28,
                height: 32,
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                    [1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
                    [1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1],
                    [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 64, y: 230 },  // S position (grid: 8,27) - converted to pixels
                goal: { x: 64, y: 32 }     // G position (grid: 8,4) - converted to pixels
            },
            {   // Stage 1: Simple Path
                id: 1,
                name: "Simple Path",
                width: 28,
                height: 32,
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 28, y: 240 },   // S position (grid: 3,28) - safe for balloon
                goal: { x: 188, y: 20 }     // G position (grid: 23,2)
            },
            {   // Stage 2: Wide Corridor
                id: 2,
                name: "Wide Corridor",
                width: 28,
                height: 32,
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                    [1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 68, y: 250 },   // S position (grid: 8,30) - safe empty area
                goal: { x: 68, y: 36 }      // G position (grid: 8,4)
            },
            {   // Stage 4: Zigzag Path (from map008.dat)
                id: 4,
                name: "Zigzag Path",
                width: 28,
                height: 32,
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 208, y: 216 }, // S position (grid: 26,27) - converted to pixels
                goal: { x: 16, y: 8 }      // G position (grid: 2,1) - converted to pixels
            },
            {   // Stage 5: Complex Maze (from map010.dat)
                id: 5,
                name: "Complex Maze",
                width: 28,
                height: 32,
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,0,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
                    [1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 64, y: 208 },  // S position (grid: 8,26) - converted to pixels
                goal: { x: 32, y: 8 }      // G position (grid: 4,1) - converted to pixels
            }
        ];

        // ===== CRAZY BALLOON GAME CLASS =====
        class CrazyBalloon {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Game constants
                this.GAME_WIDTH = 224;
                this.GAME_HEIGHT = 256;
                this.CELL_SIZE = 8;
                this.TARGET_FPS = 60;
                this.FRAME_TIME = 1000 / this.TARGET_FPS;
                
                // Game parameters 
                this.params = {
                    BALLOON_MIN_R: 4,
                    BALLOON_MAX_R: 12,
                    BALLOON_EXPAND_RATE: 8, // pixels per second
                    SPEED: 32,
                    DOT_SIZE: 2,
                    EXTEND_SCORE: 10000
                };
                
                // Game state
                this.gameState = 'TITLE';
                this.score = 0;
                this.hiScore = parseInt(localStorage.getItem('crazyBalloonHiScore') || '0');
                this.lives = 3;
                this.stage = 1;
                this.timer = 0;
                this.stageTimer = 0;
                this.stageClearTimer = 0;
                this.lastTime = 0;
                this.fps = 60;
                this.frameCount = 0;
                
                // Input system
                this.keys = {};
                this.inputVector = { x: 0, y: 0 };
                
                // Player (the character you control)
                this.player = {
                    pos: { x: 32, y: 200 },
                    size: 4
                };
                
                // Balloon (attached above player)
                this.balloon = {
                    pos: { x: 32, y: 190 },
                    radius: 6,
                    targetRadius: 6,
                    color: '#ff4444',
                    swayPhase: 0,
                    swayAmplitude: 8, // How far left/right it swings
                    stringLength: 12 // Distance from player to balloon
                };
                
                // Current stage maze
                this.currentStage = null;
                this.mazeData = [];
                
                // Effects
                this.particles = [];
                
                this.initInput();
                this.init();
            }
            
            init() {
                console.log('Initializing game...');
                this.gameState = 'LOADING';
                this.loadStageData();
                this.resetPlayer();
                this.gameState = 'TITLE';
                console.log('Game initialization complete');
                this.gameLoop();
            }
            
            initInput() {
                const keyMap = {
                    'ArrowUp': 'up',
                    'ArrowDown': 'down', 
                    'ArrowLeft': 'left',
                    'ArrowRight': 'right',
                    'KeyW': 'up',
                    'KeyS': 'down',
                    'KeyA': 'left', 
                    'KeyD': 'right',
                    'Space': 'start'
                };
                
                document.addEventListener('keydown', (e) => {
                    const key = keyMap[e.code];
                    if (key) {
                        this.keys[key] = true;
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    const key = keyMap[e.code];
                    if (key) {
                        this.keys[key] = false;
                        e.preventDefault();
                    }
                });
            }
            
            updateInput() {
                let x = 0, y = 0;
                
                if (this.keys.left) x -= 1;
                if (this.keys.right) x += 1;
                if (this.keys.up) y -= 1;
                if (this.keys.down) y += 1;
                
                // Normalize diagonal movement
                if (x !== 0 && y !== 0) {
                    const len = Math.sqrt(x * x + y * y);
                    x /= len;
                    y /= len;
                }
                
                this.inputVector.x = x;
                this.inputVector.y = y;
            }
            
            updatePlayer(dt) {
                // Player movement
                const speed = this.params.SPEED * dt / 1000;
                const newX = this.player.pos.x + this.inputVector.x * speed;
                const newY = this.player.pos.y + this.inputVector.y * speed;
                
                // Check collision before moving player
                if (!this.checkPlayerCollision({ x: newX, y: newY })) {
                    this.player.pos.x = Math.max(this.player.size, 
                                        Math.min(this.GAME_WIDTH - this.player.size, newX));
                    this.player.pos.y = Math.max(this.player.size,
                                        Math.min(this.GAME_HEIGHT - this.player.size, newY));
                }
                
                this.updateBalloon(dt);
            }
            
            updateBalloon(dt) {
                // Balloon expansion/contraction based on input
                const isMoving = this.inputVector.x !== 0 || this.inputVector.y !== 0;
                
                if (isMoving) {
                    // Expand when moving
                    this.balloon.targetRadius = Math.min(this.params.BALLOON_MAX_R, 
                        this.balloon.radius + this.params.BALLOON_EXPAND_RATE * dt / 1000);
                } else {
                    // Contract when stationary
                    this.balloon.targetRadius = Math.max(this.params.BALLOON_MIN_R, 
                        this.balloon.radius - this.params.BALLOON_EXPAND_RATE * dt / 1000);
                }
                
                // Smooth radius transition
                const radiusDiff = this.balloon.targetRadius - this.balloon.radius;
                this.balloon.radius += radiusDiff * 0.1;
                
                // Update sway animation - right → center → left → center → right
                this.balloon.swayPhase += dt * 0.002; // Sway speed
                
                // Calculate sway offset: sin wave creates right→center→left→center pattern
                const swayOffset = Math.sin(this.balloon.swayPhase) * this.balloon.swayAmplitude;
                
                // Position balloon above player with sway
                this.balloon.pos.x = this.player.pos.x + swayOffset;
                this.balloon.pos.y = this.player.pos.y - this.balloon.stringLength;
                
                // Check if reached goal (only during PLAYING state)
                if (this.gameState === 'PLAYING' && this.checkGoalReached()) {
                    this.onStageCleared();
                }
            }
            
            checkPlayerCollision(pos) {
                // Player doesn't collide with dots, only balloon does
                return false;
            }
            
            checkBalloonCollision() {
                if (!this.currentStage || !this.mazeData.length) return false;
                
                // Check balloon collision with maze dots
                for (let row = 0; row < this.mazeData.length; row++) {
                    for (let col = 0; col < this.mazeData[row].length; col++) {
                        if (this.mazeData[row][col] === 1) { // Dot exists
                            const dotX = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                            const dotY = row * this.CELL_SIZE + this.CELL_SIZE / 2;
                            
                            const distance = Math.sqrt(
                                Math.pow(this.balloon.pos.x - dotX, 2) + Math.pow(this.balloon.pos.y - dotY, 2)
                            );
                            
                            if (distance < this.balloon.radius + this.params.DOT_SIZE) {
                                return true; // Collision!
                            }
                        }
                    }
                }
                
                return false;
            }
            
            checkGoalReached() {
                if (!this.currentStage) return false;
                
                const goalX = this.currentStage.goal.x;
                const goalY = this.currentStage.goal.y;
                const distance = Math.sqrt(
                    Math.pow(this.player.pos.x - goalX, 2) + 
                    Math.pow(this.player.pos.y - goalY, 2)
                );
                
                return distance < this.player.size + 8;
            }
            
            onBalloonHit() {
                console.log(`Balloon hit! Current state: ${this.gameState}, Lives: ${this.lives}`);
                
                // Create explosion effect
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: this.balloon.pos.x,
                        y: this.balloon.pos.y,
                        vx: (Math.random() - 0.5) * 100,
                        vy: (Math.random() - 0.5) * 100,
                        life: 1.0,
                        color: this.balloon.color
                    });
                }
                
                this.lives--;
                console.log(`Lives after hit: ${this.lives}`);
                
                if (this.lives <= 0) {
                    this.gameState = 'GAME_OVER';
                    console.log('Game Over triggered');
                } else {
                    this.resetPlayer();
                }
            }
            
            onStageCleared() {
                console.log('Stage cleared!');
                this.score += 1000;
                this.stage++;
                this.stageTimer = 0;
                
                // Check for extend
                if (this.score > this.hiScore && 
                    Math.floor(this.score / this.params.EXTEND_SCORE) > 
                    Math.floor(this.hiScore / this.params.EXTEND_SCORE)) {
                    this.lives++;
                }
                
                if (this.score > this.hiScore) {
                    this.hiScore = this.score;
                    localStorage.setItem('crazyBalloonHiScore', this.hiScore.toString());
                }
                
                // Move player and balloon to safe position to prevent collision
                this.player.pos = { x: 50, y: 50 };
                this.balloon.pos = { x: 50, y: 38 };
                
                // Set state to transitioning to prevent collision checks
                this.gameState = 'STAGE_CLEAR';
                this.stageClearTimer = 0; // Reset timer for stage clear display
            }
            
            resetPlayer() {
                console.log('Resetting player...');
                if (this.currentStage) {
                    this.player.pos = { 
                        x: this.currentStage.start.x,
                        y: this.currentStage.start.y
                    };
                    console.log(`Player reset to: ${this.player.pos.x}, ${this.player.pos.y}`);
                } else {
                    this.player.pos = { x: 32, y: 200 };
                    console.log('Player reset to default position');
                }
                
                // Reset balloon properties
                this.balloon.radius = 6;
                this.balloon.targetRadius = 6;
                this.balloon.swayPhase = 0;
                
                // Clear input vector to prevent immediate movement
                this.inputVector = { x: 0, y: 0 };
                
                // Update balloon position immediately but safely
                this.balloon.pos.x = this.player.pos.x;
                this.balloon.pos.y = this.player.pos.y - this.balloon.stringLength;
                
                console.log(`Balloon reset to: ${this.balloon.pos.x}, ${this.balloon.pos.y}`);
            }
            
            loadStageData() {
                // Load stage data from STAGES array (no more fetch)
                const stageIndex = ((this.stage - 1) % STAGES.length);
                const stageData = STAGES[stageIndex];
                
                console.log(`Loading Stage ${this.stage}: ${stageData.name}`);
                
                this.mazeData = stageData.grid;
                this.currentStage = {
                    start: stageData.start,
                    goal: stageData.goal
                };
                
                console.log('Stage loaded:', this.currentStage);
            }
            
            updateParticles(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx * dt / 1000;
                    p.y += p.vy * dt / 1000;
                    p.life -= dt / 1000;
                    
                    // Remove particles that are dead or have moved off-screen
                    if (p.life <= 0 || p.x < -10 || p.x > this.canvas.width + 10 || 
                        p.y < -10 || p.y > this.canvas.height + 10) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            handleGameState() {
                if ((this.gameState === 'TITLE' || this.gameState === 'GAME_OVER') && this.keys.start) {
                    this.startGame();
                }
            }
            
            startGame() {
                this.gameState = 'LOADING';
                this.score = 0;
                this.lives = 3;
                this.stage = 1;
                this.timer = 0;
                this.stageTimer = 0;
                this.loadStageData();
                this.resetPlayer();
                this.gameState = 'PLAYING';
            }
            
            render() {
                // Clear canvas with black background
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.gameState === 'TITLE') {
                    this.renderTitle();
                } else if (this.gameState === 'LOADING') {
                    this.renderLoading();
                } else if (this.gameState === 'PLAYING') {
                    this.renderGame();
                } else if (this.gameState === 'STAGE_CLEAR') {
                    this.renderStageClear();
                } else if (this.gameState === 'GAME_OVER') {
                    this.renderGameOver();
                }
                
                this.renderDebug();
            }
            
            renderTitle() {
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('CRAZY BALLOON', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 - 40);
                
                this.ctx.fillStyle = '#ffff00';
                this.ctx.font = '12px monospace';
                this.ctx.fillText('クレイジーバルーン', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 - 20);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.fillText('Press SPACE to start', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 20);
                
                this.ctx.fillStyle = '#888';
                this.ctx.font = '10px monospace';
                this.ctx.fillText('HI-SCORE: ' + this.hiScore, this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 40);
            }
            
            renderLoading() {
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '14px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('LOADING STAGE ' + this.stage, this.GAME_WIDTH/2, this.GAME_HEIGHT/2 - 10);
                
                // Simple loading animation
                const dots = '.'.repeat((Math.floor(Date.now() / 500) % 4));
                this.ctx.fillText('PLEASE WAIT' + dots, this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 10);
            }
            
            renderStageClear() {
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('STAGE CLEAR!', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 - 20);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px monospace';
                this.ctx.fillText('Score: ' + this.score, this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 10);
                
                if (this.stage <= STAGES.length) {
                    this.ctx.fillText('Next Stage: ' + this.stage, this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 30);
                } else {
                    this.ctx.fillText('All Stages Complete!', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 30);
                }
            }
            
            renderGameOver() {
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 - 20);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px monospace';
                this.ctx.fillText('Final Score: ' + this.score, this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 10);
                this.ctx.fillText('Press SPACE to restart', this.GAME_WIDTH/2, this.GAME_HEIGHT/2 + 30);
            }
            
            renderGame() {
                // Render maze dots
                this.renderMaze();
                
                // Render goal
                this.renderGoal();
                
                // Render player (orange character you control)
                this.renderPlayer();
                
                // Render balloon (attached above player)
                this.renderBalloon();
                
                // Render particles
                this.renderParticles();
                
                // Render UI
                this.renderUI();
            }
            
            renderMaze() {
                if (!this.mazeData || this.mazeData.length === 0) {
                    console.warn('No maze data to render!');
                    return;
                }
                
                this.ctx.fillStyle = '#00aaff'; // Cyan dots like original
                
                for (let row = 0; row < this.mazeData.length; row++) {
                    if (!this.mazeData[row]) continue;
                    
                    for (let col = 0; col < this.mazeData[row].length; col++) {
                        if (this.mazeData[row][col] === 1) {
                            const x = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                            let y = row * this.CELL_SIZE + this.CELL_SIZE / 2;
                            
                            // Ensure bottom row is visible by adjusting Y position if needed
                            if (y + this.params.DOT_SIZE >= this.GAME_HEIGHT) {
                                y = this.GAME_HEIGHT - this.params.DOT_SIZE - 1;
                            }
                            
                            // Debug: Log bottom row positions
                            if (row >= 30) {
                                console.log(`Bottom row ${row}, col ${col}: x=${x}, y=${y}, canvas height=${this.GAME_HEIGHT}`);
                            }
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, this.params.DOT_SIZE, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }
            
            renderGoal() {
                if (!this.currentStage) return;
                
                const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                
                // Goal glow
                const gradient = this.ctx.createRadialGradient(
                    this.currentStage.goal.x, this.currentStage.goal.y, 0,
                    this.currentStage.goal.x, this.currentStage.goal.y, 20 * pulse
                );
                gradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(this.currentStage.goal.x - 20, this.currentStage.goal.y - 20, 40, 40);
                
                // Goal center
                this.ctx.fillStyle = '#00ff00';
                this.ctx.beginPath();
                this.ctx.arc(this.currentStage.goal.x, this.currentStage.goal.y, 6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Goal text
                this.ctx.fillStyle = '#000';
                this.ctx.font = '8px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GOAL', this.currentStage.goal.x, this.currentStage.goal.y + 2);
            }
            
            renderPlayer() {
                // Player (orange character like in original)
                this.ctx.fillStyle = '#ff8800';
                this.ctx.fillRect(
                    this.player.pos.x - this.player.size/2, 
                    this.player.pos.y - this.player.size/2, 
                    this.player.size, 
                    this.player.size
                );
            }
            
            renderBalloon() {
                const balloon = this.balloon;
                
                // String connecting player to balloon
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.pos.x, this.player.pos.y - this.player.size/2);
                this.ctx.lineTo(balloon.pos.x, balloon.pos.y + balloon.radius);
                this.ctx.stroke();
                
                // Balloon shadow
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath();
                this.ctx.arc(balloon.pos.x + 2, balloon.pos.y + 2, balloon.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Balloon gradient
                const gradient = this.ctx.createRadialGradient(
                    balloon.pos.x - balloon.radius * 0.3, 
                    balloon.pos.y - balloon.radius * 0.3, 0,
                    balloon.pos.x, balloon.pos.y, balloon.radius
                );
                gradient.addColorStop(0, '#ff8888');
                gradient.addColorStop(0.7, balloon.color);
                gradient.addColorStop(1, '#cc0000');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(balloon.pos.x, balloon.pos.y, balloon.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Balloon highlight
                this.ctx.fillStyle = 'rgba(255,255,255,0.5)';
                this.ctx.beginPath();
                this.ctx.arc(
                    balloon.pos.x - balloon.radius * 0.4, 
                    balloon.pos.y - balloon.radius * 0.4, 
                    balloon.radius * 0.2, 0, Math.PI * 2
                );
                this.ctx.fill();
            }
            
            renderParticles() {
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
            }
            
            renderUI() {
                // Score display (top right like original)
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px monospace';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('SCORE', this.GAME_WIDTH + 50, 20);
                this.ctx.fillText(this.score.toString(), this.GAME_WIDTH + 50, 35);
                
                this.ctx.fillText('HI-SCORE', this.GAME_WIDTH + 50, 55);
                this.ctx.fillText(this.hiScore.toString(), this.GAME_WIDTH + 50, 70);
                
                this.ctx.fillText('STAGE', this.GAME_WIDTH + 50, 90);
                this.ctx.fillText(this.stage.toString(), this.GAME_WIDTH + 50, 105);
                
                // Lives display (as small balloons)
                for (let i = 0; i < this.lives; i++) {
                    this.ctx.fillStyle = '#ff4444';
                    this.ctx.beginPath();
                    this.ctx.arc(this.GAME_WIDTH + 20 + i * 8, 125, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderDebug() {
                // Update debug info
                document.getElementById('score').textContent = this.score;
                document.getElementById('hiscore').textContent = this.hiScore;
                document.getElementById('stage').textContent = this.stage;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('fps').textContent = Math.round(this.fps);
                document.getElementById('gameState').textContent = this.gameState;
                document.getElementById('playerPos').textContent = 
                    `Player:${Math.round(this.player.pos.x)},${Math.round(this.player.pos.y)} Balloon:${Math.round(this.balloon.pos.x)},${Math.round(this.balloon.pos.y)} R:${Math.round(this.balloon.radius)}`;
            }
            
            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Calculate FPS and increment frame count
                if (deltaTime > 0) {
                    this.fps = 1000 / deltaTime;
                }
                this.frameCount++;
                
                // Update timers
                this.timer += deltaTime;
                if (this.gameState === 'PLAYING') {
                    this.stageTimer += deltaTime;
                } else if (this.gameState === 'STAGE_CLEAR') {
                    this.stageClearTimer += deltaTime;
                    
                    // Transition to next stage after 1 second
                    if (this.stageClearTimer >= 1000) {
                        console.log(`Loading next stage. Current stage: ${this.stage}, Total stages: ${STAGES.length}, Lives: ${this.lives}`);
                        
                        // Check if player still has lives
                        if (this.lives <= 0) {
                            console.log('No lives remaining, going to game over');
                            this.gameState = 'GAME_OVER';
                        } else {
                            // Check if we have more stages
                            if (this.stage <= STAGES.length) {
                                console.log('Loading next stage...');
                                this.loadStageData();
                                this.resetPlayer();
                                this.gameState = 'PLAYING';
                            } else {
                                // All stages completed - cycle back to stage 1
                                console.log('All stages completed, cycling back to stage 1');
                                this.stage = 1;
                                this.loadStageData();
                                this.resetPlayer();
                                this.gameState = 'PLAYING';
                            }
                            console.log(`New state: ${this.gameState}, Lives: ${this.lives}`);
                        }
                    }
                }
                
                // Update game logic only if not in stage clear state
                this.updateInput();
                this.handleGameState();
                
                // Only update game objects during PLAYING state
                if (this.gameState === 'PLAYING') {
                    this.updatePlayer(deltaTime);
                    
                    // Check balloon collision after movement
                    if (this.checkBalloonCollision()) {
                        console.log('Collision detected in game loop');
                        this.onBalloonHit();
                    }
                }
                
                // Always update particles for effects
                this.updateParticles(deltaTime);
                
                // Render
                this.render();
                
                // Schedule next frame
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // ===== INITIALIZATION =====
        window.addEventListener('load', () => {
            new CrazyBalloon();
        });
    </script>
</body>
</html> 