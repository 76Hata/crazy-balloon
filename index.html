<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <title>Crazy Balloon - クレイジーバルーン</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                background: #000;
                color: #fff;
                font-family: monospace;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                min-height: 100vh;
                padding-top: 10px;
                overflow: hidden;
                touch-action: none;
                user-select: none;
            }

            #gameCanvas {
                border: 2px solid #444;
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }

            #ui {
                margin-top: 10px;
                display: flex;
                gap: 20px;
                font-size: 14px;
            }

            #virtual-controls {
                margin-top: 5px;
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 20px;
                user-select: none;
            }

            #analog-stick {
                position: relative;
                width: 120px;
                height: 120px;
                border: 3px solid #555;
                border-radius: 50%;
                background: radial-gradient(circle at center, #222 30%, #333 70%, #444 100%);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                user-select: none;
                box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            }

            #stick-knob {
                width: 40px;
                height: 40px;
                background: radial-gradient(circle at 30% 30%, #666, #444, #222);
                border: 2px solid #777;
                border-radius: 50%;
                position: absolute;
                transition: all 0.1s ease;
                cursor: grab;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            #stick-knob:active {
                cursor: grabbing;
                transform: scale(0.95);
            }

            #stick-knob.dragging {
                transition: none;
            }

            .start-btn {
                background: #0a7c0a;
                border: 2px solid #0d8f0d;
                border-radius: 8px;
                color: #fff;
                font-size: 16px;
                font-weight: bold;
                padding: 12px 24px;
                cursor: pointer;
                transition: all 0.1s ease;
                user-select: none;
            }

            .start-btn:hover {
                background: #0d8f0d;
                border-color: #10a010;
            }

            .start-btn:active,
            .start-btn.pressed {
                background: #10a010;
                border-color: #13b013;
                transform: scale(0.95);
            }
        </style>
    </head>
    <body>
        <canvas id="gameCanvas" width="300" height="256"></canvas>
        <div id="ui">
            <div>
                SCORE:
                <span id="score">0</span>
            </div>
            <div>
                HI-SCORE:
                <span id="hiscore">0</span>
            </div>
            <div>
                STAGE:
                <span id="stage">1</span>
            </div>
            <div>
                LIVES:
                <span id="lives">3</span>
            </div>
        </div>
        <!-- 仮想コントローラー -->
        <div id="virtual-controls">
            <div id="analog-stick">
                <div id="stick-knob"></div>
            </div>
            <button id="btn-start" class="start-btn">START</button>
        </div>

        <script>
            // ===== STAGE DATA (5 STAGES) =====
            const STAGES = [
                {
                    // Stage 1: Simple Path
                    id: 1,
                    name: "Simple Path",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 28, y: 240 }, // S position (grid: 3,28) - safe for balloon
                    goal: { x: 195, y: 40 } // G position (grid: 23,2)
                },
                {
                    // Stage 2: Wide Corridor
                    id: 2,
                    name: "Wide Corridor",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 68, y: 250 }, // S position (grid: 8,30) - safe empty area
                    goal: { x: 68, y: 36 } // G position (grid: 8,4)
                },
                {
                    // Stage 3: Simple Maze (from map004.dat)
                    id: 3,
                    name: "Simple Maze",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 64, y: 220 }, // S position (grid: 8,27) - converted to pixels
                    goal: { x: 64, y: 32 } // G position (grid: 8,4) - converted to pixels
                },
                {
                    // Stage 4: Zigzag Path (from map008.dat)
                    id: 4,
                    name: "Zigzag Path",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
                        [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 200, y: 240 }, // S position (grid: 26,27) - converted to pixels
                    goal: { x: 16, y: 8 } // G position (grid: 2,1) - converted to pixels
                },
                {
                    // Stage 5: Complex Maze (from map010.dat)
                    id: 5,
                    name: "Complex Maze",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 200, y: 230 }, // S position (grid: 8,26) - converted to pixels
                    goal: { x: 125, y: 130 } // G position (grid: 4,1) - converted to pixels
                }
            ];

            // ===== CRAZY BALLOON GAME CLASS =====
            class CrazyBalloon {
                constructor() {
                    this.canvas = document.getElementById("gameCanvas");
                    this.ctx = this.canvas.getContext("2d");

                    // Game constants
                    this.GAME_WIDTH = 224;
                    this.GAME_HEIGHT = 256;
                    this.CELL_SIZE = 8;
                    this.TARGET_FPS = 60;
                    this.FRAME_TIME = 1000 / this.TARGET_FPS;

                    // Game parameters
                    this.params = {
                        BALLOON_MIN_R: 4,
                        BALLOON_MAX_R: 12,
                        BALLOON_EXPAND_RATE: 8, // pixels per second
                        SPEED: 32,
                        DOT_SIZE: 2,
                        EXTEND_SCORE: 10000,
                        STAGE_TIME_LIMIT: 300000 // 5分 (ミリ秒)
                    };

                    // Game state
                    this.gameState = "TITLE";
                    this.score = 0;
                    this.hiScore = parseInt(localStorage.getItem("crazyBalloonHiScore") || "0");
                    this.lives = 3;
                    this.stage = 1;
                    this.timer = 0;
                    this.stageTimer = 0;
                    this.stageClearTimer = 0;
                    this.restartTimer = 0;
                    this.timeUpTimer = 0;
                    this.remainingTime = this.params.STAGE_TIME_LIMIT;
                    this.lastTime = 0;
                    this.fps = 60;
                    this.frameCount = 0;
                    this.isNextStage = false; // ステージクリア時かどうかを判定
                    this.isTimeUp = false; // タイムアップ時かどうかを判定

                    // Input system
                    this.keys = {};
                    this.inputVector = { x: 0, y: 0 };

                    // Player (the character you control)
                    this.player = {
                        pos: { x: 32, y: 200 },
                        size: 4
                    };

                    // Balloon (attached above player)
                    this.balloon = {
                        pos: { x: 32, y: 190 },
                        radius: 6,
                        targetRadius: 6,
                        color: "#ff4444",
                        swayPhase: 0,
                        swayAmplitude: 8, // How far left/right it swings
                        stringLength: 12 // Distance from player to balloon
                    };

                    // Current stage maze
                    this.currentStage = null;
                    this.mazeData = [];

                    // Effects
                    this.particles = [];

                    this.initInput();
                    this.preventScrolling();
                    this.init();
                    this.updateUIVisibility();
                }

                preventScrolling() {
                    // スクロール抑制
                    document.addEventListener(
                        "touchmove",
                        (e) => {
                            // アナログスティック内での操作は除外
                            const target = e.target;
                            if (!target.closest("#analog-stick")) {
                                e.preventDefault();
                            }
                        },
                        { passive: false }
                    );

                    document.addEventListener(
                        "wheel",
                        (e) => {
                            e.preventDefault();
                        },
                        { passive: false }
                    );

                    // iOS Safariでのオーバースクロール（バウンス）を抑制
                    document.addEventListener(
                        "touchstart",
                        (e) => {
                            if (e.touches.length > 1) {
                                e.preventDefault();
                            }
                        },
                        { passive: false }
                    );
                }

                init() {
                    console.log("Initializing game...");
                    this.gameState = "LOADING";
                    this.loadStageData();
                    this.resetPlayer();
                    this.gameState = "TITLE";
                    console.log("Game initialization complete");
                    this.gameLoop();
                }

                initInput() {
                    const keyMap = {
                        ArrowUp: "up",
                        ArrowDown: "down",
                        ArrowLeft: "left",
                        ArrowRight: "right",
                        KeyW: "up",
                        KeyS: "down",
                        KeyA: "left",
                        KeyD: "right",
                        Space: "start"
                    };

                    // キーボードイベント
                    document.addEventListener("keydown", (e) => {
                        const key = keyMap[e.code];
                        if (key) {
                            this.keys[key] = true;
                            e.preventDefault();
                        }
                    });

                    document.addEventListener("keyup", (e) => {
                        const key = keyMap[e.code];
                        if (key) {
                            this.keys[key] = false;
                            e.preventDefault();
                        }
                    });

                    // 仮想コントローラーのイベント
                    this.setupVirtualControls();

                    // ゲーム画面のタップでスタート（スペースキー代替）
                    document.getElementById("gameCanvas").addEventListener("click", (e) => {
                        if (this.gameState === "TITLE" || this.gameState === "GAME_OVER") {
                            this.keys.start = true;
                            setTimeout(() => {
                                this.keys.start = false;
                            }, 100);
                        }
                        e.preventDefault();
                    });
                }

                setupVirtualControls() {
                    // アナログスティックの設定
                    this.setupAnalogStick();

                    // STARTボタンのイベント設定
                    const startButton = document.getElementById("btn-start");
                    ["mousedown", "touchstart"].forEach((eventType) => {
                        startButton.addEventListener(eventType, (e) => {
                            this.keys.start = true;
                            startButton.classList.add("pressed");
                            e.preventDefault();
                        });
                    });

                    ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach((eventType) => {
                        startButton.addEventListener(eventType, (e) => {
                            this.keys.start = false;
                            startButton.classList.remove("pressed");
                            e.preventDefault();
                        });
                    });
                }

                setupAnalogStick() {
                    const stick = document.getElementById("analog-stick");
                    const knob = document.getElementById("stick-knob");

                    if (!stick || !knob) return;

                    const stickRect = stick.getBoundingClientRect();
                    const stickCenterX = stickRect.width / 2;
                    const stickCenterY = stickRect.height / 2;
                    const maxDistance = (stickRect.width - 40) / 2; // 40 = knob width

                    let isDragging = false;
                    let currentX = 0;
                    let currentY = 0;

                    const getEventPos = (e) => {
                        const rect = stick.getBoundingClientRect();
                        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                        return {
                            x: clientX - rect.left - stickCenterX,
                            y: clientY - rect.top - stickCenterY
                        };
                    };

                    const updateKnobPosition = (x, y) => {
                        const distance = Math.sqrt(x * x + y * y);

                        if (distance > maxDistance) {
                            const angle = Math.atan2(y, x);
                            x = Math.cos(angle) * maxDistance;
                            y = Math.sin(angle) * maxDistance;
                        }

                        currentX = x;
                        currentY = y;

                        knob.style.transform = `translate(${x}px, ${y}px)`;

                        // 正規化された方向ベクトルを計算
                        const normalizedX = distance > 0 ? x / maxDistance : 0;
                        const normalizedY = distance > 0 ? y / maxDistance : 0;

                        this.updateInputFromStick(normalizedX, normalizedY);
                    };

                    const resetKnob = () => {
                        currentX = 0;
                        currentY = 0;
                        knob.style.transform = "translate(0px, 0px)";
                        this.updateInputFromStick(0, 0);
                    };

                    // マウスイベント
                    knob.addEventListener("mousedown", (e) => {
                        isDragging = true;
                        knob.classList.add("dragging");
                        e.preventDefault();
                    });

                    document.addEventListener("mousemove", (e) => {
                        if (!isDragging) return;

                        const pos = getEventPos(e);
                        updateKnobPosition(pos.x, pos.y);
                        e.preventDefault();
                    });

                    document.addEventListener("mouseup", () => {
                        if (isDragging) {
                            isDragging = false;
                            knob.classList.remove("dragging");
                            resetKnob();
                        }
                    });

                    // タッチイベント
                    knob.addEventListener("touchstart", (e) => {
                        isDragging = true;
                        knob.classList.add("dragging");
                        e.preventDefault();
                    });

                    document.addEventListener(
                        "touchmove",
                        (e) => {
                            if (!isDragging) return;

                            const pos = getEventPos(e);
                            updateKnobPosition(pos.x, pos.y);
                            e.preventDefault();
                        },
                        { passive: false }
                    );

                    document.addEventListener("touchend", () => {
                        if (isDragging) {
                            isDragging = false;
                            knob.classList.remove("dragging");
                            resetKnob();
                        }
                    });

                    document.addEventListener("touchcancel", () => {
                        if (isDragging) {
                            isDragging = false;
                            knob.classList.remove("dragging");
                            resetKnob();
                        }
                    });
                }

                updateInputFromStick(x, y) {
                    // アナログスティックからの入力をキー入力形式に変換
                    const deadZone = 0.1; // デッドゾーン

                    if (Math.abs(x) < deadZone) x = 0;
                    if (Math.abs(y) < deadZone) y = 0;

                    // 直接 inputVector を更新
                    this.inputVector.x = x;
                    this.inputVector.y = y;

                    // 互換性のためキー状態も更新（必要に応じて）
                    this.keys.left = x < -deadZone;
                    this.keys.right = x > deadZone;
                    this.keys.up = y < -deadZone;
                    this.keys.down = y > deadZone;
                }

                updateInput() {
                    // アナログスティックが使用されている場合はキーボード入力を無効化
                    if (this.inputVector.x !== 0 || this.inputVector.y !== 0) {
                        // アナログスティックからの入力が既に設定されているので何もしない
                        return;
                    }

                    let x = 0,
                        y = 0;

                    if (this.keys.left) x -= 1;
                    if (this.keys.right) x += 1;
                    if (this.keys.up) y -= 1;
                    if (this.keys.down) y += 1;

                    // Normalize diagonal movement
                    if (x !== 0 && y !== 0) {
                        const len = Math.sqrt(x * x + y * y);
                        x /= len;
                        y /= len;
                    }

                    this.inputVector.x = x;
                    this.inputVector.y = y;
                }

                updatePlayer(dt) {
                    // Player movement
                    const speed = (this.params.SPEED * dt) / 1000;
                    const newX = this.player.pos.x + this.inputVector.x * speed;
                    const newY = this.player.pos.y + this.inputVector.y * speed;

                    // Check collision before moving player
                    if (!this.checkPlayerCollision({ x: newX, y: newY })) {
                        this.player.pos.x = Math.max(
                            this.player.size,
                            Math.min(this.GAME_WIDTH - this.player.size, newX)
                        );
                        this.player.pos.y = Math.max(
                            this.player.size,
                            Math.min(this.GAME_HEIGHT - this.player.size, newY)
                        );
                    }

                    this.updateBalloon(dt);
                }

                updateBalloon(dt) {
                    // Balloon expansion/contraction based on input
                    const isMoving = this.inputVector.x !== 0 || this.inputVector.y !== 0;

                    if (isMoving) {
                        // Expand when moving
                        this.balloon.targetRadius = Math.min(
                            this.params.BALLOON_MAX_R,
                            this.balloon.radius + (this.params.BALLOON_EXPAND_RATE * dt) / 1000
                        );
                    } else {
                        // Contract when stationary
                        this.balloon.targetRadius = Math.max(
                            this.params.BALLOON_MIN_R,
                            this.balloon.radius - (this.params.BALLOON_EXPAND_RATE * dt) / 1000
                        );
                    }

                    // Smooth radius transition
                    const radiusDiff = this.balloon.targetRadius - this.balloon.radius;
                    this.balloon.radius += radiusDiff * 0.1;

                    // Update sway animation - right → center → left → center → right
                    this.balloon.swayPhase += dt * 0.002; // Sway speed

                    // Calculate sway offset: sin wave creates right→center→left→center pattern
                    const swayOffset = Math.sin(this.balloon.swayPhase) * this.balloon.swayAmplitude;

                    // Position balloon above player with sway
                    this.balloon.pos.x = this.player.pos.x + swayOffset;
                    this.balloon.pos.y = this.player.pos.y - this.balloon.stringLength;

                    // Check if reached goal (only during PLAYING state)
                    if (this.gameState === "PLAYING" && this.checkGoalReached()) {
                        this.onStageCleared();
                    }
                }

                checkPlayerCollision(_pos) {
                    // Player doesn't collide with dots, only balloon does
                    return false;
                }

                checkBalloonCollision() {
                    if (!this.currentStage || !this.mazeData.length) return false;

                    // Check balloon collision with maze dots
                    for (let row = 0; row < this.mazeData.length; row++) {
                        for (let col = 0; col < this.mazeData[row].length; col++) {
                            if (this.mazeData[row][col] === 1) {
                                // Dot exists
                                const dotX = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                                const dotY = row * this.CELL_SIZE + this.CELL_SIZE / 2;

                                const distance = Math.sqrt(
                                    Math.pow(this.balloon.pos.x - dotX, 2) + Math.pow(this.balloon.pos.y - dotY, 2)
                                );

                                if (distance < this.balloon.radius + this.params.DOT_SIZE) {
                                    return true; // Collision!
                                }
                            }
                        }
                    }

                    return false;
                }

                checkGoalReached() {
                    if (!this.currentStage) return false;

                    const goalX = this.currentStage.goal.x;
                    const goalY = this.currentStage.goal.y;
                    const distance = Math.sqrt(
                        Math.pow(this.player.pos.x - goalX, 2) + Math.pow(this.player.pos.y - goalY, 2)
                    );

                    return distance < this.player.size + 8;
                }

                onBalloonHit() {
                    console.log(`Balloon hit! Current state: ${this.gameState}, Lives: ${this.lives}`);

                    // Create explosion effect
                    for (let i = 0; i < 12; i++) {
                        this.particles.push({
                            x: this.balloon.pos.x,
                            y: this.balloon.pos.y,
                            vx: (Math.random() - 0.5) * 100,
                            vy: (Math.random() - 0.5) * 100,
                            life: 1.0,
                            color: this.balloon.color
                        });
                    }

                    this.lives--;
                    console.log(`Lives after hit: ${this.lives}`);

                    if (this.lives <= 0) {
                        this.gameState = "GAME_OVER";
                        this.updateUIVisibility();
                        console.log("Game Over triggered");
                    } else {
                        // リスタート時はプレイヤーを初期位置に戻してRESTART状態に遷移
                        this.resetPlayer();
                        this.resetStageTimer();
                        this.gameState = "RESTART";
                        this.restartTimer = 0;
                        this.isNextStage = false; // ミス時のリスタート
                        this.isTimeUp = false;
                        console.log("Restarting stage - showing RESTART message");
                    }
                }

                onTimeUp() {
                    console.log("Time up!");

                    this.lives--;
                    console.log(`Lives after time up: ${this.lives}`);

                    if (this.lives <= 0) {
                        this.gameState = "GAME_OVER";
                        this.updateUIVisibility();
                        console.log("Game Over triggered by time up");
                    } else {
                        // タイムアップ時はプレイヤーを初期位置に戻してRESTART状態に遷移
                        this.resetPlayer();
                        this.resetStageTimer();
                        this.gameState = "RESTART";
                        this.restartTimer = 0;
                        this.isNextStage = false;
                        this.isTimeUp = true; // タイムアップ時のリスタート
                        console.log("Time up restart - showing TIME UP message");
                    }
                }

                onStageCleared() {
                    console.log("Stage cleared!");
                    this.score += 1000;
                    this.stage++;
                    this.stageTimer = 0;

                    // ステージクリア時に自機を1機増やす
                    this.lives++;
                    console.log(`Stage cleared bonus: Lives increased to ${this.lives}`);

                    // Check for extend
                    if (
                        this.score > this.hiScore &&
                        Math.floor(this.score / this.params.EXTEND_SCORE) >
                            Math.floor(this.hiScore / this.params.EXTEND_SCORE)
                    ) {
                        this.lives++;
                    }

                    if (this.score > this.hiScore) {
                        this.hiScore = this.score;
                        localStorage.setItem("crazyBalloonHiScore", this.hiScore.toString());
                    }

                    // Move player and balloon to safe position to prevent collision
                    this.player.pos = { x: 50, y: 50 };
                    this.balloon.pos = { x: 50, y: 38 };

                    // Set state to transitioning to prevent collision checks
                    this.gameState = "STAGE_CLEAR";
                    this.stageClearTimer = 0; // Reset timer for stage clear display
                }

                resetPlayer() {
                    console.log("Resetting player...");
                    console.log("Current stage:", this.currentStage);
                    if (this.currentStage) {
                        this.player.pos = {
                            x: this.currentStage.start.x,
                            y: this.currentStage.start.y
                        };
                        console.log(
                            `Player reset to stage ${this.stage} start position: ${this.player.pos.x}, ${this.player.pos.y}`
                        );
                    } else {
                        this.player.pos = { x: 32, y: 200 };
                        console.log("WARNING: No currentStage found, using default position");
                    }

                    // Reset balloon properties
                    this.balloon.radius = 6;
                    this.balloon.targetRadius = 6;
                    this.balloon.swayPhase = 0;

                    // Clear input vector to prevent immediate movement
                    this.inputVector = { x: 0, y: 0 };

                    // Update balloon position immediately but safely
                    this.balloon.pos.x = this.player.pos.x;
                    this.balloon.pos.y = this.player.pos.y - this.balloon.stringLength;

                    console.log(`Balloon reset to: ${this.balloon.pos.x}, ${this.balloon.pos.y}`);
                }

                loadStageData() {
                    // Load stage data from STAGES array (no more fetch)
                    const stageIndex = (this.stage - 1) % STAGES.length;
                    const stageData = STAGES[stageIndex];

                    console.log(`Loading Stage ${this.stage} (index: ${stageIndex}): ${stageData.name}`);

                    this.mazeData = stageData.grid;
                    this.currentStage = {
                        start: stageData.start,
                        goal: stageData.goal
                    };

                    console.log(
                        `Stage loaded: ${this.currentStage.start.x}, ${this.currentStage.start.y} -> ${this.currentStage.goal.x}, ${this.currentStage.goal.y}`
                    );
                    console.log(`Grid dimensions: ${this.mazeData.length}x${this.mazeData[0]?.length}`);
                }

                updateParticles(dt) {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.x += (p.vx * dt) / 1000;
                        p.y += (p.vy * dt) / 1000;
                        p.life -= dt / 1000;

                        // Remove particles that are dead or have moved off-screen
                        if (
                            p.life <= 0 ||
                            p.x < -10 ||
                            p.x > this.canvas.width + 10 ||
                            p.y < -10 ||
                            p.y > this.canvas.height + 10
                        ) {
                            this.particles.splice(i, 1);
                        }
                    }
                }

                handleGameState() {
                    if ((this.gameState === "TITLE" || this.gameState === "GAME_OVER") && this.keys.start) {
                        this.startGame();
                    }
                }

                startGame() {
                    this.gameState = "LOADING";
                    this.score = 0;
                    this.lives = 3;
                    this.stage = 1;
                    this.timer = 0;
                    this.stageTimer = 0;
                    this.remainingTime = this.params.STAGE_TIME_LIMIT;
                    this.loadStageData();
                    this.resetPlayer();
                    this.gameState = "PLAYING";
                    this.updateUIVisibility();
                }

                resetStageTimer() {
                    this.remainingTime = this.params.STAGE_TIME_LIMIT;
                    this.stageTimer = 0;
                    const seconds = this.params.STAGE_TIME_LIMIT / 1000;
                    console.log(`Stage timer reset - ${seconds} seconds remaining`);
                }

                updateUIVisibility() {
                    const startButton = document.getElementById("btn-start");
                    const analogStick = document.getElementById("analog-stick");

                    if (startButton) {
                        if (this.gameState === "TITLE" || this.gameState === "GAME_OVER") {
                            startButton.style.display = "block";
                        } else {
                            startButton.style.display = "none";
                        }
                    }

                    if (analogStick) {
                        if (this.gameState === "TITLE" || this.gameState === "GAME_OVER") {
                            analogStick.style.display = "none";
                        } else {
                            analogStick.style.display = "flex";
                        }
                    }
                }

                render() {
                    // Clear canvas with black background
                    this.ctx.fillStyle = "#000";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    if (this.gameState === "TITLE") {
                        this.renderTitle();
                    } else if (this.gameState === "LOADING") {
                        this.renderLoading();
                    } else if (this.gameState === "PLAYING") {
                        this.renderGame();
                    } else if (this.gameState === "RESTART") {
                        this.renderRestart();
                    } else if (this.gameState === "STAGE_CLEAR") {
                        this.renderStageClear();
                    } else if (this.gameState === "GAME_OVER") {
                        this.renderGameOver();
                    }
                }

                renderTitle() {
                    this.ctx.fillStyle = "#00ffff";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("CRAZY BALLOON", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 40);

                    this.ctx.fillStyle = "#ffff00";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText("クレイジーバルーン", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 20);

                    this.ctx.fillStyle = "#fff";
                    this.ctx.fillText("Press SPACE to start", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 20);

                    this.ctx.fillStyle = "#888";
                    this.ctx.font = "10px monospace";
                    this.ctx.fillText("HI-SCORE: " + this.hiScore, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 40);
                }

                renderLoading() {
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "14px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("LOADING STAGE " + this.stage, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 10);

                    // Simple loading animation
                    const dots = ".".repeat(Math.floor(Date.now() / 500) % 4);
                    this.ctx.fillText("PLEASE WAIT" + dots, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 10);
                }

                renderStageClear() {
                    this.ctx.fillStyle = "#00ff00";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("STAGE CLEAR!", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 20);

                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText("Score: " + this.score, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 10);

                    if (this.stage <= STAGES.length) {
                        this.ctx.fillText("Next Stage: " + this.stage, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);
                    } else {
                        this.ctx.fillText("All Stages Complete!", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);
                    }
                }

                renderGameOver() {
                    this.ctx.fillStyle = "#ff0000";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("GAME OVER", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 20);

                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText("Final Score: " + this.score, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 10);
                    this.ctx.fillText("Press SPACE to restart", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);
                }

                renderRestart() {
                    // 背景にゲーム画面を薄く表示
                    this.ctx.globalAlpha = 0.3;
                    this.renderGame();
                    this.ctx.globalAlpha = 1.0;

                    // 半透明の黒い背景
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // メッセージ（ステージクリア時・タイムアップ時・ミス時で異なる）
                    let messageColor = "#ffff00";
                    let messageText = "RESTART!";

                    if (this.isNextStage) {
                        messageColor = "#00ff00";
                        messageText = "NEXT STAGE!";
                    } else if (this.isTimeUp) {
                        messageColor = "#ff0000";
                        messageText = "TIME UP!";
                    }

                    this.ctx.fillStyle = messageColor;
                    this.ctx.font = "20px monospace";
                    this.ctx.textAlign = "center";

                    // アニメーション効果（点滅）
                    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                    this.ctx.globalAlpha = pulse;
                    this.ctx.fillText(messageText, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2);

                    this.ctx.globalAlpha = 1.0;

                    // ライフ表示
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText(`LIVES: ${this.lives}`, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);

                    // ステージ情報も表示
                    if (this.isNextStage) {
                        this.ctx.fillText(`STAGE ${this.stage}`, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 30);
                    }
                }

                renderGame() {
                    // Render maze dots
                    this.renderMaze();

                    // Render goal
                    this.renderGoal();

                    // Render player (orange character you control)
                    this.renderPlayer();

                    // Render balloon (attached above player)
                    this.renderBalloon();

                    // Render particles
                    this.renderParticles();

                    // Render UI
                    this.renderUI();
                }

                renderMaze() {
                    if (!this.mazeData || this.mazeData.length === 0) {
                        console.warn("No maze data to render!");
                        return;
                    }

                    // Debug: Log maze data info every few frames (avoid spam)
                    if (this.timer % 3000 < 50) {
                        console.log(
                            `Rendering maze for stage ${this.stage}, maze size: ${this.mazeData.length}x${this.mazeData[0]?.length}`
                        );
                        // Log first few rows for comparison
                        console.log("First row:", this.mazeData[0]?.slice(0, 10));
                        console.log("Second row:", this.mazeData[1]?.slice(0, 10));
                    }

                    this.ctx.fillStyle = "#00aaff"; // Cyan dots like original

                    for (let row = 0; row < this.mazeData.length; row++) {
                        if (!this.mazeData[row]) continue;

                        for (let col = 0; col < this.mazeData[row].length; col++) {
                            if (this.mazeData[row][col] === 1) {
                                const x = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                                let y = row * this.CELL_SIZE + this.CELL_SIZE / 2;

                                // Ensure bottom row is visible by adjusting Y position if needed
                                if (y + this.params.DOT_SIZE >= this.GAME_HEIGHT) {
                                    y = this.GAME_HEIGHT - this.params.DOT_SIZE - 1;
                                }

                                // Debug: Log bottom row positions
                                if (row >= 30) {
                                    console.log(
                                        `Bottom row ${row}, col ${col}: x=${x}, y=${y}, canvas height=${this.GAME_HEIGHT}`
                                    );
                                }

                                this.ctx.beginPath();
                                this.ctx.arc(x, y, this.params.DOT_SIZE, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                    }
                }

                renderGoal() {
                    if (!this.currentStage) return;

                    const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;

                    // Goal glow
                    const gradient = this.ctx.createRadialGradient(
                        this.currentStage.goal.x,
                        this.currentStage.goal.y,
                        0,
                        this.currentStage.goal.x,
                        this.currentStage.goal.y,
                        20 * pulse
                    );
                    gradient.addColorStop(0, "rgba(0, 255, 0, 0.8)");
                    gradient.addColorStop(1, "rgba(0, 255, 0, 0)");

                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(this.currentStage.goal.x - 20, this.currentStage.goal.y - 20, 40, 40);

                    // Goal center
                    this.ctx.fillStyle = "#00ff00";
                    this.ctx.beginPath();
                    this.ctx.arc(this.currentStage.goal.x, this.currentStage.goal.y, 6, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Goal text
                    this.ctx.fillStyle = "#000";
                    this.ctx.font = "8px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("GOAL", this.currentStage.goal.x, this.currentStage.goal.y + 2);
                }

                renderPlayer() {
                    // Player (orange character like in original)
                    this.ctx.fillStyle = "#ff8800";
                    this.ctx.fillRect(
                        this.player.pos.x - this.player.size / 2,
                        this.player.pos.y - this.player.size / 2,
                        this.player.size,
                        this.player.size
                    );
                }

                renderBalloon() {
                    const balloon = this.balloon;

                    // String connecting player to balloon
                    this.ctx.strokeStyle = "#666";
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.pos.x, this.player.pos.y - this.player.size / 2);
                    this.ctx.lineTo(balloon.pos.x, balloon.pos.y + balloon.radius);
                    this.ctx.stroke();

                    // Balloon shadow
                    this.ctx.fillStyle = "rgba(0,0,0,0.3)";
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.pos.x + 2, balloon.pos.y + 2, balloon.radius, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Balloon gradient
                    const gradient = this.ctx.createRadialGradient(
                        balloon.pos.x - balloon.radius * 0.3,
                        balloon.pos.y - balloon.radius * 0.3,
                        0,
                        balloon.pos.x,
                        balloon.pos.y,
                        balloon.radius
                    );
                    gradient.addColorStop(0, "#ff8888");
                    gradient.addColorStop(0.7, balloon.color);
                    gradient.addColorStop(1, "#cc0000");

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.pos.x, balloon.pos.y, balloon.radius, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Balloon highlight
                    this.ctx.fillStyle = "rgba(255,255,255,0.5)";
                    this.ctx.beginPath();
                    this.ctx.arc(
                        balloon.pos.x - balloon.radius * 0.4,
                        balloon.pos.y - balloon.radius * 0.4,
                        balloon.radius * 0.2,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }

                renderParticles() {
                    this.particles.forEach((p) => {
                        this.ctx.fillStyle = p.color;
                        this.ctx.globalAlpha = p.life;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                    this.ctx.globalAlpha = 1;
                }

                renderUI() {
                    // Score display (top right like original)
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "10px monospace";
                    this.ctx.textAlign = "right";
                    this.ctx.fillText("SCORE", this.GAME_WIDTH + 50, 20);
                    this.ctx.fillText(this.score.toString(), this.GAME_WIDTH + 50, 35);

                    this.ctx.fillText("HI-SCORE", this.GAME_WIDTH + 50, 55);
                    this.ctx.fillText(this.hiScore.toString(), this.GAME_WIDTH + 50, 70);

                    this.ctx.fillText("STAGE", this.GAME_WIDTH + 50, 90);
                    this.ctx.fillText(this.stage.toString(), this.GAME_WIDTH + 50, 105);

                    // Timer display
                    const seconds = Math.ceil(this.remainingTime / 1000);
                    const displayTime = Math.max(0, seconds);

                    // 時間が少なくなったら色を変える
                    if (displayTime <= 10) {
                        this.ctx.fillStyle = "#ff0000"; // 赤色
                    } else if (displayTime <= 20) {
                        this.ctx.fillStyle = "#ffaa00"; // オレンジ色
                    } else {
                        this.ctx.fillStyle = "#fff"; // 白色
                    }

                    this.ctx.fillText("TIME", this.GAME_WIDTH + 50, 125);
                    this.ctx.fillText(displayTime.toString(), this.GAME_WIDTH + 50, 140);

                    // Lives display (as small balloons)
                    for (let i = 0; i < this.lives; i++) {
                        this.ctx.fillStyle = "#ff4444";
                        this.ctx.beginPath();
                        this.ctx.arc(this.GAME_WIDTH + 20 + i * 8, 155, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }

                    // Update HTML UI elements
                    this.updateHTMLUI();
                }

                updateHTMLUI() {
                    // Update score, stage, and lives in HTML UI
                    const scoreElement = document.getElementById("score");
                    const hiScoreElement = document.getElementById("hiscore");
                    const stageElement = document.getElementById("stage");
                    const livesElement = document.getElementById("lives");

                    if (scoreElement) scoreElement.textContent = this.score.toString();
                    if (hiScoreElement) hiScoreElement.textContent = this.hiScore.toString();
                    if (stageElement) stageElement.textContent = this.stage.toString();
                    if (livesElement) livesElement.textContent = this.lives.toString();
                }

                gameLoop() {
                    const currentTime = performance.now();
                    const deltaTime = currentTime - this.lastTime;
                    this.lastTime = currentTime;

                    // Calculate FPS and increment frame count
                    if (deltaTime > 0) {
                        this.fps = 1000 / deltaTime;
                    }
                    this.frameCount++;

                    // Update timers
                    this.timer += deltaTime;
                    if (this.gameState === "PLAYING") {
                        this.stageTimer += deltaTime;
                    } else if (this.gameState === "RESTART") {
                        this.restartTimer += deltaTime;

                        // 1.5秒後にPLAYING状態に戻る
                        if (this.restartTimer >= 1500) {
                            this.gameState = "PLAYING";
                            console.log("Restart complete - returning to PLAYING state");
                        }
                    } else if (this.gameState === "STAGE_CLEAR") {
                        this.stageClearTimer += deltaTime;

                        // Transition to next stage after 1 second
                        if (this.stageClearTimer >= 1000) {
                            console.log(
                                `Loading next stage. Current stage: ${this.stage}, Total stages: ${STAGES.length}, Lives: ${this.lives}`
                            );

                            // Check if player still has lives
                            if (this.lives <= 0) {
                                console.log("No lives remaining, going to game over");
                                this.gameState = "GAME_OVER";
                            } else {
                                // Check if we have more stages
                                if (this.stage <= STAGES.length) {
                                    console.log(
                                        `Loading next stage... Current stage: ${this.stage}, STAGES.length: ${STAGES.length}`
                                    );
                                    console.log(
                                        `Before loadStageData: mazeData size: ${this.mazeData?.length || "undefined"}`
                                    );
                                    this.loadStageData();
                                    console.log(
                                        `After loadStageData: mazeData size: ${this.mazeData?.length || "undefined"}, first row size: ${this.mazeData?.[0]?.length || "undefined"}`
                                    );
                                    this.resetPlayer();
                                    this.resetStageTimer();
                                    this.gameState = "RESTART";
                                    this.restartTimer = 0;
                                    this.isNextStage = true; // 次ステージへの遷移
                                    this.isTimeUp = false;
                                } else {
                                    // All stages completed - cycle back to stage 1
                                    console.log("All stages completed, cycling back to stage 1");
                                    this.stage = 1;
                                    this.loadStageData();
                                    this.resetPlayer();
                                    this.resetStageTimer();
                                    this.gameState = "RESTART";
                                    this.restartTimer = 0;
                                    this.isNextStage = true; // 次ステージへの遷移
                                    this.isTimeUp = false;
                                }
                                console.log(`New state: ${this.gameState}, Lives: ${this.lives}`);
                            }
                        }
                    }

                    // Update game logic only if not in special states
                    this.updateInput();
                    this.handleGameState();

                    // Only update game objects during PLAYING state
                    if (this.gameState === "PLAYING") {
                        this.updatePlayer(deltaTime);

                        // Update timer
                        this.remainingTime -= deltaTime;
                        if (this.remainingTime <= 0) {
                            this.remainingTime = 0;
                            this.onTimeUp();
                        }

                        // Check balloon collision after movement
                        if (this.checkBalloonCollision()) {
                            console.log("Collision detected in game loop");
                            this.onBalloonHit();
                        }
                    }

                    // Reset input vector for next frame (will be set by analog stick if needed)
                    this.inputVector = { x: 0, y: 0 };

                    // Always update particles for effects
                    this.updateParticles(deltaTime);

                    // Render
                    this.render();

                    // Schedule next frame
                    requestAnimationFrame(() => this.gameLoop());
                }
            }

            // ===== INITIALIZATION =====
            window.addEventListener("load", () => {
                new CrazyBalloon();
            });
        </script>
    </body>
</html>
