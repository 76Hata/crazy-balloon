<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <title>Crazy Balloon - クレイジーバルーン</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                background: #000;
                color: #fff;
                font-family: monospace;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                min-height: 100vh;
                padding-top: 10px;
                overflow: hidden;
                touch-action: none;
                user-select: none;
            }

            #gameCanvas {
                border: 2px solid #444;
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }

            #ui {
                margin-top: 10px;
                display: flex;
                gap: 20px;
                font-size: 14px;
            }

            #virtual-controls {
                margin-top: 5px;
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 20px;
                user-select: none;
            }

            #analog-stick {
                position: relative;
                width: 120px;
                height: 120px;
                border: 3px solid #555;
                border-radius: 50%;
                background: radial-gradient(circle at center, #222 30%, #333 70%, #444 100%);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                user-select: none;
                box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            }

            #stick-knob {
                width: 40px;
                height: 40px;
                background: radial-gradient(circle at 30% 30%, #666, #444, #222);
                border: 2px solid #777;
                border-radius: 50%;
                position: absolute;
                transition: all 0.1s ease;
                cursor: grab;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            #stick-knob:active {
                cursor: grabbing;
                transform: scale(0.95);
            }

            #stick-knob.dragging {
                transition: none;
            }

            .start-btn {
                background: #0a7c0a;
                border: 2px solid #0d8f0d;
                border-radius: 8px;
                color: #fff;
                font-size: 16px;
                font-weight: bold;
                padding: 12px 24px;
                cursor: pointer;
                transition: all 0.1s ease;
                user-select: none;
            }

            .start-btn:hover {
                background: #0d8f0d;
                border-color: #10a010;
            }

            .start-btn:active,
            .start-btn.pressed {
                background: #10a010;
                border-color: #13b013;
                transform: scale(0.95);
            }
        </style>
    </head>

    <body>
        <canvas id="gameCanvas" width="300" height="256"></canvas>
        <div id="ui">
            <div>
                SCORE:
                <span id="score">0</span>
            </div>
            <div>
                HI-SCORE:
                <span id="hiscore">0</span>
            </div>
            <div>
                STAGE:
                <span id="stage">1</span>
            </div>
            <div>
                LIVES:
                <span id="lives">3</span>
            </div>
        </div>
        <!-- 仮想コントローラー -->
        <div id="virtual-controls">
            <div id="analog-stick">
                <div id="stick-knob"></div>
            </div>
            <button id="btn-start" class="start-btn">START</button>
        </div>

        <script>
            // ===== STAGE DATA (5 STAGES) =====
            const STAGES = [
                {
                    // Stage 1: Simple Path
                    id: 1,
                    name: "Simple Path",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 28, y: 240 }, // S position (grid: 3,28) - safe for balloon
                    goal: { x: 195, y: 40 } // G position (grid: 23,2)
                },
                {
                    // Stage 2: Wide Corridor
                    id: 2,
                    name: "Wide Corridor",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 68, y: 250 }, // S position (grid: 8,30) - safe empty area
                    goal: { x: 68, y: 36 } // G position (grid: 8,4)
                },
                {
                    // Stage 3: Simple Maze (from map004.dat)
                    id: 3,
                    name: "Simple Maze",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 64, y: 220 }, // S position (grid: 8,27) - converted to pixels
                    goal: { x: 64, y: 32 } // G position (grid: 8,4) - converted to pixels
                },
                {
                    // Stage 4: Zigzag Path (from map008.dat)
                    id: 4,
                    name: "Zigzag Path",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
                        [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                        [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 200, y: 240 }, // S position (grid: 26,27) - converted to pixels
                    goal: { x: 16, y: 8 } // G position (grid: 2,1) - converted to pixels
                },
                {
                    // Stage 5: Complex Maze (from map010.dat)
                    id: 5,
                    name: "Complex Maze",
                    width: 28,
                    height: 32,
                    grid: [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],
                        [1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1],
                        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ],
                    start: { x: 200, y: 230 }, // S position (grid: 8,26) - converted to pixels
                    goal: { x: 125, y: 130 } // G position (grid: 4,1) - converted to pixels
                }
            ];

            // ===== ゲーム状態管理クラス =====
            /**
             * ゲームの状態遷移を管理するクラス
             * 単一責任原則：ゲーム状態の管理のみに責任を持つ
             */
            class GameStateManager {
                constructor() {
                    this.currentState = "TITLE"; // 現在のゲーム状態
                    this.collisionDetectionEnabled = true; // 衝突判定の有効/無効
                }

                /**
                 * ゲーム状態を設定する
                 * @param {string} newState - 新しい状態
                 */
                setState(newState) {
                    console.log(`State transition: ${this.currentState} -> ${newState}`);
                    this.currentState = newState;
                    
                    // 状態に応じて衝突判定の制御
                    this.updateCollisionDetection();
                }

                /**
                 * 現在の状態を取得する
                 * @returns {string} 現在の状態
                 */
                getState() {
                    return this.currentState;
                }

                /**
                 * 衝突判定が有効かどうかを確認
                 * @returns {boolean} 衝突判定が有効かどうか
                 */
                isCollisionDetectionEnabled() {
                    return this.collisionDetectionEnabled;
                }

                /**
                 * 状態に応じて衝突判定の有効/無効を制御
                 */
                updateCollisionDetection() {
                    // PLAYINGステート以外では衝突判定を無効にする
                    this.collisionDetectionEnabled = this.currentState === "PLAYING";
                }

                /**
                 * プレイ中かどうかを判定
                 * @returns {boolean} プレイ中かどうか
                 */
                isPlaying() {
                    return this.currentState === "PLAYING";
                }

                /**
                 * ゲーム開始可能な状態かどうかを判定
                 * @returns {boolean} ゲーム開始可能かどうか
                 */
                canStartGame() {
                    return this.currentState === "TITLE" || this.currentState === "GAME_OVER";
                }
            }

            // ===== 衝突判定クラス =====
            /**
             * 衝突判定を管理するクラス
             * 単一責任原則：衝突判定の処理のみに責任を持つ
             */
            class CollisionDetector {
                constructor(params) {
                    this.params = params; // ゲームパラメータ
                    this.CELL_SIZE = 8;
                }

                /**
                 * 風船と迷路の衝突判定
                 * @param {Object} balloon - 風船オブジェクト
                 * @param {Array} mazeData - 迷路データ
                 * @returns {boolean} 衝突しているかどうか
                 */
                checkBalloonCollision(balloon, mazeData) {
                    if (!mazeData || !mazeData.length) return false;

                    // 迷路内の各ドットとの衝突判定
                    for (let row = 0; row < mazeData.length; row++) {
                        for (let col = 0; col < mazeData[row].length; col++) {
                            if (mazeData[row][col] === 1) {
                                // ドットが存在する場合の衝突判定
                                const dotX = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                                const dotY = row * this.CELL_SIZE + this.CELL_SIZE / 2;
                                const distance = Math.sqrt(
                                    Math.pow(balloon.pos.x - dotX, 2) + 
                                    Math.pow(balloon.pos.y - dotY, 2)
                                );
                                
                                if (distance < balloon.radius + this.params.DOT_SIZE) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                }

                /**
                 * ゴール到達判定
                 * @param {Object} player - プレイヤーオブジェクト
                 * @param {Object} goal - ゴールオブジェクト
                 * @returns {boolean} ゴールに到達しているかどうか
                 */
                checkGoalReached(player, goal) {
                    if (!goal) return false;
                    
                    const distance = Math.sqrt(
                        Math.pow(player.pos.x - goal.x, 2) + 
                        Math.pow(player.pos.y - goal.y, 2)
                    );
                    return distance < 12; // ゴール判定距離
                }
            }

            // ===== プレイヤー制御クラス =====
            /**
             * プレイヤーと風船の動作を制御するクラス
             * 単一責任原則：プレイヤーの動作制御のみに責任を持つ
             */
            class PlayerController {
                constructor(params) {
                    this.params = params; // ゲームパラメータ
                }

                /**
                 * プレイヤーの位置を更新
                 * @param {Object} player - プレイヤーオブジェクト
                 * @param {Object} inputVector - 入力ベクトル
                 * @param {number} deltaTime - 経過時間
                 */
                updatePlayerPosition(player, inputVector, deltaTime) {
                    // 入力に基づいてプレイヤーを移動
                    if (inputVector.x !== 0 || inputVector.y !== 0) {
                        const speed = this.params.SPEED * (deltaTime / 1000);
                        player.pos.x += inputVector.x * speed;
                        player.pos.y += inputVector.y * speed;
                    }

                    // 画面境界チェック
                    this.constrainPlayerToBounds(player);
                }

                /**
                 * プレイヤーを画面境界内に制限
                 * @param {Object} player - プレイヤーオブジェクト
                 */
                constrainPlayerToBounds(player) {
                    const margin = player.size;
                    player.pos.x = Math.max(margin, Math.min(224 - margin, player.pos.x));
                    player.pos.y = Math.max(margin, Math.min(256 - margin, player.pos.y));
                }

                /**
                 * 風船の位置と状態を更新
                 * @param {Object} balloon - 風船オブジェクト
                 * @param {Object} player - プレイヤーオブジェクト
                 * @param {Object} inputVector - 入力ベクトル
                 * @param {number} deltaTime - 経過時間
                 */
                updateBalloon(balloon, player, inputVector, deltaTime) {
                    // 風船の揺れ効果を更新
                    balloon.swayPhase += deltaTime * 0.003;
                    const swayOffset = Math.sin(balloon.swayPhase) * balloon.swayAmplitude;

                    // 風船の位置を更新（プレイヤーの上に配置）
                    balloon.pos.x = player.pos.x + swayOffset;
                    balloon.pos.y = player.pos.y - balloon.stringLength;

                    // 風船のサイズ制御
                    this.updateBalloonSize(balloon, inputVector, deltaTime);
                }

                /**
                 * 風船のサイズを更新
                 * @param {Object} balloon - 風船オブジェクト
                 * @param {Object} inputVector - 入力ベクトル
                 * @param {number} deltaTime - 経過時間
                 */
                updateBalloonSize(balloon, inputVector, deltaTime) {
                    const isMoving = inputVector.x !== 0 || inputVector.y !== 0;
                    
                    if (isMoving) {
                        // 移動中は風船が膨らむ（段階的に）
                        balloon.targetRadius = Math.min(
                            this.params.BALLOON_MAX_R,
                            balloon.radius + (this.params.BALLOON_EXPAND_RATE * deltaTime) / 1000
                        );
                    } else {
                        // 静止中は風船が縮む（段階的に）
                        balloon.targetRadius = Math.max(
                            this.params.BALLOON_MIN_R,
                            balloon.radius - (this.params.BALLOON_EXPAND_RATE * deltaTime) / 1000
                        );
                    }

                    // スムーズな半径の遷移（以前のロジックを再現）
                    const radiusDiff = balloon.targetRadius - balloon.radius;
                    balloon.radius += radiusDiff * 0.1;
                }
            }

            // ===== ステージ管理クラス =====
            /**
             * ステージの読み込みと管理を行うクラス
             * 単一責任原則：ステージ管理のみに責任を持つ
             */
            class StageManager {
                constructor() {
                    this.currentStage = null; // 現在のステージ
                    this.mazeData = []; // 迷路データ
                }

                /**
                 * ステージデータを読み込み
                 * @param {number} stageNumber - ステージ番号
                 */
                loadStage(stageNumber) {
                    const stageIndex = ((stageNumber - 1) % STAGES.length);
                    const stageData = STAGES[stageIndex];
                    
                    console.log(`Loading stage ${stageNumber} (index: ${stageIndex})`);
                    console.log(`Stage data:`, stageData.name);
                    
                    this.currentStage = {
                        id: stageData.id,
                        name: stageData.name,
                        width: stageData.width,
                        height: stageData.height,
                        start: stageData.start,
                        goal: stageData.goal
                    };
                    this.mazeData = stageData.grid;
                    
                    console.log(`Loaded ${stageData.name}`);
                }

                /**
                 * 現在のステージを取得
                 * @returns {Object} 現在のステージ
                 */
                getCurrentStage() {
                    return this.currentStage;
                }

                /**
                 * 迷路データを取得
                 * @returns {Array} 迷路データ
                 */
                getMazeData() {
                    return this.mazeData;
                }
            }

            // ===== メインゲームクラス =====
            /**
             * ゲーム全体を統括するメインクラス
             * 依存性逆転原則：具体的な実装ではなく抽象化に依存
             */
            class CrazyBalloon {
                constructor() {
                    // Canvas要素とコンテキストの取得
                    this.canvas = document.getElementById("gameCanvas");
                    this.ctx = this.canvas.getContext("2d");

                    // ゲーム定数
                    this.GAME_WIDTH = 224;
                    this.GAME_HEIGHT = 256;
                    this.CELL_SIZE = 8;
                    this.TARGET_FPS = 60;
                    this.FRAME_TIME = 1000 / this.TARGET_FPS;

                    // ゲームパラメータ
                    this.params = {
                        BALLOON_MIN_R: 4, // 風船の最小半径
                        BALLOON_MAX_R: 12, // 風船の最大半径
                        BALLOON_EXPAND_RATE: 8, // 風船の膨張速度（ピクセル/秒）
                        SPEED: 32, // プレイヤーの移動速度
                        DOT_SIZE: 2, // ドットのサイズ
                        EXTEND_SCORE: 10000, // エクステンドスコア
                        STAGE_TIME_LIMIT: 300000 // ステージ制限時間（5分、ミリ秒）
                    };

                    // 依存性注入：各管理クラスのインスタンス化
                    this.stateManager = new GameStateManager();
                    this.collisionDetector = new CollisionDetector(this.params);
                    this.playerController = new PlayerController(this.params);
                    this.stageManager = new StageManager();

                    // ゲームスコアとライフ
                    this.score = 0;
                    this.hiScore = parseInt(localStorage.getItem("crazyBalloonHiScore") || "0");
                    this.lives = 3;
                    this.stage = 1; // 現在のステージ番号

                    // タイマー関連
                    this.timer = 0; // 総経過時間
                    this.stageTimer = 0; // ステージ経過時間
                    this.stageClearTimer = 0; // ステージクリア表示時間
                    this.restartTimer = 0; // リスタート待機時間
                    this.timeUpTimer = 0; // タイムアップ表示時間
                    this.remainingTime = this.params.STAGE_TIME_LIMIT; // 残り時間
                    this.lastTime = 0; // 前フレームの時間
                    this.fps = 60; // フレームレート
                    this.frameCount = 0; // フレームカウンタ
                    
                    // ステージ状態フラグ
                    this.isNextStage = false; // 次ステージへの遷移かどうか
                    this.isTimeUp = false; // タイムアップによるリスタートかどうか

                    // 入力システム
                    this.keys = {}; // キー入力状態
                    this.inputVector = { x: 0, y: 0 }; // 入力ベクトル

                    // プレイヤー（操作するキャラクター）
                    this.player = {
                        pos: { x: 32, y: 200 }, // 位置
                        size: 4 // サイズ
                    };

                    // 風船（プレイヤーの上に付いている）
                    this.balloon = {
                        pos: { x: 32, y: 190 }, // 位置
                        radius: 6, // 現在の半径
                        targetRadius: 6, // 目標半径
                        color: "#ff4444", // 色
                        swayPhase: 0, // 揺れのフェーズ
                        swayAmplitude: 8, // 左右の揺れ幅
                        stringLength: 12 // プレイヤーから風船までの距離
                    };

                    // エフェクト用パーティクル
                    this.particles = [];

                    // 初期化処理
                    this.initInput();
                    this.preventScrolling();
                    this.init();
                    this.updateUIVisibility();
                }

                /**
                 * スクロール抑制の設定
                 * タッチデバイスでのページスクロールを防ぐ
                 */
                preventScrolling() {
                    // タッチムーブイベントのスクロール抑制
                    document.addEventListener(
                        "touchmove",
                        (e) => {
                            // アナログスティック内での操作は除外
                            const target = e.target;
                            if (!target.closest("#analog-stick")) {
                                e.preventDefault();
                            }
                        },
                        { passive: false }
                    );

                    // マウスホイールによるスクロール抑制
                    document.addEventListener(
                        "wheel",
                        (e) => {
                            e.preventDefault();
                        },
                        { passive: false }
                    );

                    // iOS Safariでのオーバースクロール（バウンス）を抑制
                    document.addEventListener(
                        "touchstart",
                        (e) => {
                            if (e.touches.length > 1) {
                                e.preventDefault();
                            }
                        },
                        { passive: false }
                    );
                }

                /**
                 * ゲームの初期化処理
                 * ステージデータの読み込みとプレイヤーの初期配置を行う
                 */
                init() {
                    console.log("Initializing game...");
                    this.stateManager.setState("LOADING");
                    this.loadStageData();
                    this.resetPlayer();
                    this.stateManager.setState("TITLE");
                    console.log("Game initialization complete");
                    this.gameLoop();
                }

                /**
                 * 入力システムの初期化
                 * キーボードとタッチイベントの設定を行う
                 */
                initInput() {
                    // キー配置の定義
                    const keyMap = {
                        ArrowUp: "up",
                        ArrowDown: "down",
                        ArrowLeft: "left",
                        ArrowRight: "right",
                        KeyW: "up",
                        KeyS: "down",
                        KeyA: "left",
                        KeyD: "right",
                        Space: "start"
                    };

                    // キーボードイベント
                    document.addEventListener("keydown", (e) => {
                        const key = keyMap[e.code];
                        if (key) {
                            this.keys[key] = true;
                            e.preventDefault();
                        }
                    });

                    document.addEventListener("keyup", (e) => {
                        const key = keyMap[e.code];
                        if (key) {
                            this.keys[key] = false;
                            e.preventDefault();
                        }
                    });

                    // 仮想コントローラーのイベント
                    this.setupVirtualControls();

                    // ゲーム画面のタップでスタート（スペースキー代替）
                    document.getElementById("gameCanvas").addEventListener("click", (e) => {
                        if (this.stateManager.canStartGame()) {
                            this.keys.start = true;
                            setTimeout(() => {
                                this.keys.start = false;
                            }, 100);
                        }
                        e.preventDefault();
                    });
                }

                setupVirtualControls() {
                    // アナログスティックの設定
                    this.setupAnalogStick();

                    // STARTボタンのイベント設定
                    const startButton = document.getElementById("btn-start");
                    ["mousedown", "touchstart"].forEach((eventType) => {
                        startButton.addEventListener(eventType, (e) => {
                            this.keys.start = true;
                            startButton.classList.add("pressed");
                            e.preventDefault();
                        });
                    });

                    ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach((eventType) => {
                        startButton.addEventListener(eventType, (e) => {
                            this.keys.start = false;
                            startButton.classList.remove("pressed");
                            e.preventDefault();
                        });
                    });
                }

                setupAnalogStick() {
                    const stick = document.getElementById("analog-stick");
                    const knob = document.getElementById("stick-knob");

                    if (!stick || !knob) return;

                    const stickRect = stick.getBoundingClientRect();
                    const stickCenterX = stickRect.width / 2;
                    const stickCenterY = stickRect.height / 2;
                    const maxDistance = (stickRect.width - 40) / 2; // 40 = knob width

                    let isDragging = false;
                    let currentX = 0;
                    let currentY = 0;

                    const getEventPos = (e) => {
                        const rect = stick.getBoundingClientRect();
                        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                        return {
                            x: clientX - rect.left - stickCenterX,
                            y: clientY - rect.top - stickCenterY
                        };
                    };

                    const updateKnobPosition = (x, y) => {
                        const distance = Math.sqrt(x * x + y * y);

                        if (distance > maxDistance) {
                            const angle = Math.atan2(y, x);
                            x = Math.cos(angle) * maxDistance;
                            y = Math.sin(angle) * maxDistance;
                        }

                        currentX = x;
                        currentY = y;

                        knob.style.transform = `translate(${x}px, ${y}px)`;

                        // 正規化された方向ベクトルを計算
                        const normalizedX = distance > 0 ? x / maxDistance : 0;
                        const normalizedY = distance > 0 ? y / maxDistance : 0;

                        this.updateInputFromStick(normalizedX, normalizedY);
                    };

                    const resetKnob = () => {
                        currentX = 0;
                        currentY = 0;
                        knob.style.transform = "translate(0px, 0px)";
                        this.updateInputFromStick(0, 0);
                    };

                    // マウスイベント
                    knob.addEventListener("mousedown", (e) => {
                        isDragging = true;
                        knob.classList.add("dragging");
                        e.preventDefault();
                    });

                    document.addEventListener("mousemove", (e) => {
                        if (!isDragging) return;

                        const pos = getEventPos(e);
                        updateKnobPosition(pos.x, pos.y);
                        e.preventDefault();
                    });

                    document.addEventListener("mouseup", () => {
                        if (isDragging) {
                            isDragging = false;
                            knob.classList.remove("dragging");
                            resetKnob();
                        }
                    });

                    // タッチイベント
                    knob.addEventListener("touchstart", (e) => {
                        isDragging = true;
                        knob.classList.add("dragging");
                        e.preventDefault();
                    });

                    document.addEventListener(
                        "touchmove",
                        (e) => {
                            if (!isDragging) return;

                            const pos = getEventPos(e);
                            updateKnobPosition(pos.x, pos.y);
                            e.preventDefault();
                        },
                        { passive: false }
                    );

                    document.addEventListener("touchend", () => {
                        if (isDragging) {
                            isDragging = false;
                            knob.classList.remove("dragging");
                            resetKnob();
                        }
                    });

                    document.addEventListener("touchcancel", () => {
                        if (isDragging) {
                            isDragging = false;
                            knob.classList.remove("dragging");
                            resetKnob();
                        }
                    });
                }

                updateInputFromStick(x, y) {
                    // アナログスティックからの入力をキー入力形式に変換
                    const deadZone = 0.1; // デッドゾーン

                    if (Math.abs(x) < deadZone) x = 0;
                    if (Math.abs(y) < deadZone) y = 0;

                    // 直接 inputVector を更新
                    this.inputVector.x = x;
                    this.inputVector.y = y;

                    // 互換性のためキー状態も更新（必要に応じて）
                    this.keys.left = x < -deadZone;
                    this.keys.right = x > deadZone;
                    this.keys.up = y < -deadZone;
                    this.keys.down = y > deadZone;
                }

                updateInput() {
                    // アナログスティックが使用されている場合はキーボード入力を無効化
                    if (this.inputVector.x !== 0 || this.inputVector.y !== 0) {
                        // アナログスティックからの入力が既に設定されているので何もしない
                        return;
                    }

                    let x = 0,
                        y = 0;

                    if (this.keys.left) x -= 1;
                    if (this.keys.right) x += 1;
                    if (this.keys.up) y -= 1;
                    if (this.keys.down) y += 1;

                    // Normalize diagonal movement
                    if (x !== 0 && y !== 0) {
                        const len = Math.sqrt(x * x + y * y);
                        x /= len;
                        y /= len;
                    }

                    this.inputVector.x = x;
                    this.inputVector.y = y;
                }

                /**
                 * プレイヤーの更新
                 * PlayerControllerに委謗してプレイヤーと風船の位置を更新
                 * @param {number} dt - デルタタイム
                 */
                updatePlayer(dt) {
                    // PlayerControllerを使用してプレイヤーの位置を更新
                    this.playerController.updatePlayerPosition(this.player, this.inputVector, dt);
                    
                    // PlayerControllerを使用して風船の位置と状態を更新
                    this.playerController.updateBalloon(this.balloon, this.player, this.inputVector, dt);

                    // ゴール判定（PLAYING状態かつ衝突判定が有効な場合のみ）
                    if (this.stateManager.isPlaying() && this.stateManager.isCollisionDetectionEnabled()) {
                        const currentStage = this.stageManager.getCurrentStage();
                        if (currentStage && this.collisionDetector.checkGoalReached(this.player, currentStage.goal)) {
                            this.onStageCleared();
                        }
                    }
                }

                /**
                 * 風船の更新処理（非推奨）
                 * このメソッドはupdatePlayerから呼び出されるため、直接呼び出さないでください
                 * @deprecated PlayerController.updateBalloonを使用してください
                 */
                updateBalloon(dt) {
                    // このメソッドは空にして、PlayerControllerで処理する
                    // 下位互換性のために残しておく
                }

                /**
                 * プレイヤーの衝突判定
                 * プレイヤーはドットと衝突しない、風船のみが衝突する
                 * @param {Object} _pos - プレイヤーの位置（使用しない）
                 * @returns {boolean} 常にfalse
                 */
                checkPlayerCollision(_pos) {
                    return false;
                }

                /**
                 * 風船の衝突判定
                 * CollisionDetectorに委謗して処理を実行
                 * @returns {boolean} 衝突しているかどうか
                 */
                checkBalloonCollision() {
                    // 衝突判定が無効な場合は衝突しない
                    if (!this.stateManager.isCollisionDetectionEnabled()) {
                        return false;
                    }
                    
                    const mazeData = this.stageManager.getMazeData();
                    return this.collisionDetector.checkBalloonCollision(this.balloon, mazeData);
                }

                /**
                 * ゴール到達判定
                 * CollisionDetectorに委謗して処理を実行
                 * @returns {boolean} ゴールに到達しているかどうか
                 */
                checkGoalReached() {
                    const currentStage = this.stageManager.getCurrentStage();
                    if (!currentStage) return false;
                    
                    return this.collisionDetector.checkGoalReached(this.player, currentStage.goal);
                }

                /**
                 * 風船が衝突した時の処理
                 * ライフを減らし、爆発エフェクトを生成してリスタート処理を行う
                 */
                onBalloonHit() {
                    console.log(`Balloon hit! Current state: ${this.stateManager.getState()}, Lives: ${this.lives}`);

                    // 爆発エフェクトの生成
                    for (let i = 0; i < 12; i++) {
                        this.particles.push({
                            x: this.balloon.pos.x,
                            y: this.balloon.pos.y,
                            vx: (Math.random() - 0.5) * 100,
                            vy: (Math.random() - 0.5) * 100,
                            life: 1.0,
                            color: this.balloon.color
                        });
                    }

                    // ライフを減らす
                    this.lives--;
                    console.log(`Lives after hit: ${this.lives}`);

                    if (this.lives <= 0) {
                        // ゲームオーバー処理
                        this.stateManager.setState("GAME_OVER");
                        this.updateUIVisibility();
                        console.log("Game Over triggered");
                    } else {
                        // リスタート処理（プレイヤーを初期位置に戻してRESTART状態に遷移）
                        this.resetPlayer();
                        this.resetStageTimer();
                        this.stateManager.setState("RESTART");
                        this.restartTimer = 0;
                        this.isNextStage = false; // ミス時のリスタート
                        this.isTimeUp = false;
                        console.log("Restarting stage - showing RESTART message");
                    }
                }

                /**
                 * タイムアップ時の処理
                 * ライフを減らし、リスタートあるいはゲームオーバー処理を行う
                 */
                onTimeUp() {
                    console.log("Time up!");

                    // ライフを減らす
                    this.lives--;
                    console.log(`Lives after time up: ${this.lives}`);

                    if (this.lives <= 0) {
                        // ゲームオーバー処理
                        this.stateManager.setState("GAME_OVER");
                        this.updateUIVisibility();
                        console.log("Game Over triggered by time up");
                    } else {
                        // タイムアップリスタート処理
                        this.resetPlayer();
                        this.resetStageTimer();
                        this.stateManager.setState("RESTART");
                        this.restartTimer = 0;
                        this.isNextStage = false;
                        this.isTimeUp = true; // タイムアップフラグ
                        console.log("Time up restart - showing TIME UP message");
                    }
                }

                /**
                 * ステージクリア時の処理
                 * スコア加算、ライフボーナス、ハイスコア更新を行う
                 */
                onStageCleared() {
                    console.log("Stage cleared!");
                    
                    // スコア加算とステージ進行
                    this.score += 1000;
                    this.stage++;
                    this.stageTimer = 0;

                    // ステージクリア時のライフボーナス
                    this.lives++;
                    console.log(`Stage cleared bonus: Lives increased to ${this.lives}`);

                    // エクステンドスコアチェック
                    if (
                        this.score > this.hiScore &&
                        Math.floor(this.score / this.params.EXTEND_SCORE) >
                            Math.floor(this.hiScore / this.params.EXTEND_SCORE)
                    ) {
                        this.lives++; // エクステンドボーナス
                    }

                    // ハイスコア更新
                    if (this.score > this.hiScore) {
                        this.hiScore = this.score;
                        localStorage.setItem("crazyBalloonHiScore", this.hiScore.toString());
                    }

                    // 衝突を防ぐためにプレイヤーと風船を安全な位置に移動
                    this.player.pos = { x: 50, y: 50 };
                    this.balloon.pos = { x: 50, y: 38 };

                    // 衝突判定を停止するためにSTAGE_CLEAR状態に設定
                    this.stateManager.setState("STAGE_CLEAR");
                    this.stageClearTimer = 0; // ステージクリア表示用タイマーのリセット
                }

                /**
                 * プレイヤーと風船のリセット
                 * ステージ開始位置にプレイヤーを配置し、風船を初期化
                 */
                resetPlayer() {
                    console.log("Resetting player...");
                    const currentStage = this.stageManager.getCurrentStage();
                    console.log("Current stage:", currentStage);
                    
                    if (currentStage) {
                        // ステージの開始位置にプレイヤーを配置
                        this.player.pos = {
                            x: currentStage.start.x,
                            y: currentStage.start.y
                        };
                        console.log(
                            `Player reset to stage ${this.stage} start position: ${this.player.pos.x}, ${this.player.pos.y}`
                        );
                    } else {
                        // ステージデータがない場合のデフォルト位置
                        this.player.pos = { x: 32, y: 200 };
                        console.log("WARNING: No currentStage found, using default position");
                    }

                    // 風船のプロパティリセット
                    this.balloon.radius = 6;
                    this.balloon.targetRadius = 6;
                    this.balloon.swayPhase = 0;

                    // 入力ベクトルをクリアして突然の移動を防ぐ
                    this.inputVector = { x: 0, y: 0 };

                    // 風船の位置を即座に安全に更新
                    this.balloon.pos.x = this.player.pos.x;
                    this.balloon.pos.y = this.player.pos.y - this.balloon.stringLength;

                    console.log(`Balloon reset to: ${this.balloon.pos.x}, ${this.balloon.pos.y}`);
                }

                /**
                 * ステージデータの読み込み
                 * StageManagerに委謗して処理を実行し、メインゲームクラスのデータも更新
                 */
                loadStageData() {
                    this.stageManager.loadStage(this.stage);
                    
                    // StageManagerからデータを取得してメインゲームクラスを更新
                    this.currentStage = this.stageManager.getCurrentStage();
                    this.mazeData = this.stageManager.getMazeData();
                    
                    console.log(`Stage data loaded: ${this.currentStage?.name}, maze size: ${this.mazeData?.length}x${this.mazeData?.[0]?.length}`);
                }

                updateParticles(dt) {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.x += (p.vx * dt) / 1000;
                        p.y += (p.vy * dt) / 1000;
                        p.life -= dt / 1000;

                        // Remove particles that are dead or have moved off-screen
                        if (
                            p.life <= 0 ||
                            p.x < -10 ||
                            p.x > this.canvas.width + 10 ||
                            p.y < -10 ||
                            p.y > this.canvas.height + 10
                        ) {
                            this.particles.splice(i, 1);
                        }
                    }
                }

                /**
                 * ゲーム状態の処理
                 * スペースキーでのゲーム開始処理を行う
                 */
                handleGameState() {
                    if (this.stateManager.canStartGame() && this.keys.start) {
                        this.startGame();
                    }
                }

                /**
                 * ゲーム開始処理
                 * ゲーム状態を初期化してプレイ状態に遷移
                 */
                startGame() {
                    this.stateManager.setState("LOADING");
                    this.score = 0;
                    this.lives = 3;
                    this.stage = 1;
                    this.timer = 0;
                    this.stageTimer = 0;
                    this.remainingTime = this.params.STAGE_TIME_LIMIT;
                    this.loadStageData();
                    this.resetPlayer();
                    this.stateManager.setState("PLAYING");
                    this.updateUIVisibility();
                }

                /**
                 * ステージタイマーのリセット
                 * ステージの残り時間を初期値に戻す
                 */
                resetStageTimer() {
                    this.remainingTime = this.params.STAGE_TIME_LIMIT;
                    this.stageTimer = 0;
                    const seconds = this.params.STAGE_TIME_LIMIT / 1000;
                    console.log(`Stage timer reset - ${seconds} seconds remaining`);
                }

                /**
                 * UI要素の表示/非表示制御
                 * ゲーム状態に応じてスタートボタンやアナログスティックの表示を制御
                 */
                updateUIVisibility() {
                    const startButton = document.getElementById("btn-start");
                    const analogStick = document.getElementById("analog-stick");

                    if (startButton) {
                        if (this.stateManager.canStartGame()) {
                            startButton.style.display = "block";
                        } else {
                            startButton.style.display = "none";
                        }
                    }

                    if (analogStick) {
                        if (this.stateManager.canStartGame()) {
                            analogStick.style.display = "none";
                        } else {
                            analogStick.style.display = "flex";
                        }
                    }
                }

                /**
                 * メイン描画処理
                 * ゲーム状態に応じて適切な描画メソッドを呼び出す
                 */
                render() {
                    // キャンバスを黒でクリア
                    this.ctx.fillStyle = "#000";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    const currentState = this.stateManager.getState();
                    switch (currentState) {
                        case "TITLE":
                            this.renderTitle();
                            break;
                        case "LOADING":
                            this.renderLoading();
                            break;
                        case "PLAYING":
                            this.renderGame();
                            break;
                        case "RESTART":
                            this.renderRestart();
                            break;
                        case "STAGE_CLEAR":
                            this.renderStageClear();
                            break;
                        case "GAME_OVER":
                            this.renderGameOver();
                            break;
                        default:
                            console.warn(`Unknown game state: ${currentState}`);
                            break;
                    }
                }

                renderTitle() {
                    this.ctx.fillStyle = "#00ffff";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("CRAZY BALLOON", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 40);

                    this.ctx.fillStyle = "#ffff00";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText("クレイジーバルーン", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 20);

                    this.ctx.fillStyle = "#fff";
                    this.ctx.fillText("Press SPACE to start", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 20);

                    this.ctx.fillStyle = "#888";
                    this.ctx.font = "10px monospace";
                    this.ctx.fillText("HI-SCORE: " + this.hiScore, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 40);
                }

                renderLoading() {
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "14px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("LOADING STAGE " + this.stage, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 10);

                    // Simple loading animation
                    const dots = ".".repeat(Math.floor(Date.now() / 500) % 4);
                    this.ctx.fillText("PLEASE WAIT" + dots, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 10);
                }

                renderStageClear() {
                    this.ctx.fillStyle = "#00ff00";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("STAGE CLEAR!", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 20);

                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText("Score: " + this.score, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 10);

                    if (this.stage <= STAGES.length) {
                        this.ctx.fillText("Next Stage: " + this.stage, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);
                    } else {
                        this.ctx.fillText("All Stages Complete!", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);
                    }
                }

                renderGameOver() {
                    this.ctx.fillStyle = "#ff0000";
                    this.ctx.font = "16px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("GAME OVER", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 20);

                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText("Final Score: " + this.score, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 10);
                    this.ctx.fillText("Press SPACE to restart", this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);
                }

                renderRestart() {
                    // 背景にゲーム画面を薄く表示
                    this.ctx.globalAlpha = 0.3;
                    this.renderGame();
                    this.ctx.globalAlpha = 1.0;

                    // 半透明の黒い背景
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // メッセージ（ステージクリア時・タイムアップ時・ミス時で異なる）
                    let messageColor = "#ffff00";
                    let messageText = "RESTART!";

                    if (this.isNextStage) {
                        messageColor = "#00ff00";
                        messageText = "NEXT STAGE!";
                    } else if (this.isTimeUp) {
                        messageColor = "#ff0000";
                        messageText = "TIME UP!";
                    }

                    this.ctx.fillStyle = messageColor;
                    this.ctx.font = "20px monospace";
                    this.ctx.textAlign = "center";

                    // アニメーション効果（点滅）
                    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                    this.ctx.globalAlpha = pulse;
                    this.ctx.fillText(messageText, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2);

                    this.ctx.globalAlpha = 1.0;

                    // ライフ表示
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "12px monospace";
                    this.ctx.fillText(`LIVES: ${this.lives}`, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 + 30);

                    // ステージ情報も表示
                    if (this.isNextStage) {
                        this.ctx.fillText(`STAGE ${this.stage}`, this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2 - 30);
                    }
                }

                renderGame() {
                    // Render maze dots
                    this.renderMaze();

                    // Render goal
                    this.renderGoal();

                    // Render player (orange character you control)
                    this.renderPlayer();

                    // Render balloon (attached above player)
                    this.renderBalloon();

                    // Render particles
                    this.renderParticles();

                    // Render UI
                    this.renderUI();
                }

                renderMaze() {
                    if (!this.mazeData || this.mazeData.length === 0) {
                        console.warn("No maze data to render!");
                        return;
                    }

                    // Debug: Log maze data info every few frames (avoid spam)
                    if (this.timer % 3000 < 50) {
                        console.log(
                            `Rendering maze for stage ${this.stage}, maze size: ${this.mazeData.length}x${this.mazeData[0]?.length}`
                        );
                        // Log first few rows for comparison
                        console.log("First row:", this.mazeData[0]?.slice(0, 10));
                        console.log("Second row:", this.mazeData[1]?.slice(0, 10));
                    }

                    this.ctx.fillStyle = "#00aaff"; // Cyan dots like original

                    for (let row = 0; row < this.mazeData.length; row++) {
                        if (!this.mazeData[row]) continue;

                        for (let col = 0; col < this.mazeData[row].length; col++) {
                            if (this.mazeData[row][col] === 1) {
                                const x = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                                let y = row * this.CELL_SIZE + this.CELL_SIZE / 2;

                                // Ensure bottom row is visible by adjusting Y position if needed
                                if (y + this.params.DOT_SIZE >= this.GAME_HEIGHT) {
                                    y = this.GAME_HEIGHT - this.params.DOT_SIZE - 1;
                                }

                                // Debug: Log bottom row positions
                                if (row >= 30) {
                                    console.log(
                                        `Bottom row ${row}, col ${col}: x=${x}, y=${y}, canvas height=${this.GAME_HEIGHT}`
                                    );
                                }

                                this.ctx.beginPath();
                                this.ctx.arc(x, y, this.params.DOT_SIZE, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                    }
                }

                renderGoal() {
                    if (!this.currentStage) return;

                    const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;

                    // Goal glow
                    const gradient = this.ctx.createRadialGradient(
                        this.currentStage.goal.x,
                        this.currentStage.goal.y,
                        0,
                        this.currentStage.goal.x,
                        this.currentStage.goal.y,
                        20 * pulse
                    );
                    gradient.addColorStop(0, "rgba(0, 255, 0, 0.8)");
                    gradient.addColorStop(1, "rgba(0, 255, 0, 0)");

                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(this.currentStage.goal.x - 20, this.currentStage.goal.y - 20, 40, 40);

                    // Goal center
                    this.ctx.fillStyle = "#00ff00";
                    this.ctx.beginPath();
                    this.ctx.arc(this.currentStage.goal.x, this.currentStage.goal.y, 6, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Goal text
                    this.ctx.fillStyle = "#000";
                    this.ctx.font = "8px monospace";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("GOAL", this.currentStage.goal.x, this.currentStage.goal.y + 2);
                }

                renderPlayer() {
                    // Player (orange character like in original)
                    this.ctx.fillStyle = "#ff8800";
                    this.ctx.fillRect(
                        this.player.pos.x - this.player.size / 2,
                        this.player.pos.y - this.player.size / 2,
                        this.player.size,
                        this.player.size
                    );
                }

                renderBalloon() {
                    const balloon = this.balloon;

                    // String connecting player to balloon
                    this.ctx.strokeStyle = "#666";
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.pos.x, this.player.pos.y - this.player.size / 2);
                    this.ctx.lineTo(balloon.pos.x, balloon.pos.y + balloon.radius);
                    this.ctx.stroke();

                    // Balloon shadow
                    this.ctx.fillStyle = "rgba(0,0,0,0.3)";
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.pos.x + 2, balloon.pos.y + 2, balloon.radius, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Balloon gradient
                    const gradient = this.ctx.createRadialGradient(
                        balloon.pos.x - balloon.radius * 0.3,
                        balloon.pos.y - balloon.radius * 0.3,
                        0,
                        balloon.pos.x,
                        balloon.pos.y,
                        balloon.radius
                    );
                    gradient.addColorStop(0, "#ff8888");
                    gradient.addColorStop(0.7, balloon.color);
                    gradient.addColorStop(1, "#cc0000");

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.pos.x, balloon.pos.y, balloon.radius, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Balloon highlight
                    this.ctx.fillStyle = "rgba(255,255,255,0.5)";
                    this.ctx.beginPath();
                    this.ctx.arc(
                        balloon.pos.x - balloon.radius * 0.4,
                        balloon.pos.y - balloon.radius * 0.4,
                        balloon.radius * 0.2,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }

                renderParticles() {
                    this.particles.forEach((p) => {
                        this.ctx.fillStyle = p.color;
                        this.ctx.globalAlpha = p.life;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                    this.ctx.globalAlpha = 1;
                }

                renderUI() {
                    // Score display (top right like original)
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "10px monospace";
                    this.ctx.textAlign = "right";
                    this.ctx.fillText("SCORE", this.GAME_WIDTH + 50, 20);
                    this.ctx.fillText(this.score.toString(), this.GAME_WIDTH + 50, 35);

                    this.ctx.fillText("HI-SCORE", this.GAME_WIDTH + 50, 55);
                    this.ctx.fillText(this.hiScore.toString(), this.GAME_WIDTH + 50, 70);

                    this.ctx.fillText("STAGE", this.GAME_WIDTH + 50, 90);
                    this.ctx.fillText(this.stage.toString(), this.GAME_WIDTH + 50, 105);

                    // Timer display
                    const seconds = Math.ceil(this.remainingTime / 1000);
                    const displayTime = Math.max(0, seconds);

                    // 時間が少なくなったら色を変える
                    if (displayTime <= 10) {
                        this.ctx.fillStyle = "#ff0000"; // 赤色
                    } else if (displayTime <= 20) {
                        this.ctx.fillStyle = "#ffaa00"; // オレンジ色
                    } else {
                        this.ctx.fillStyle = "#fff"; // 白色
                    }

                    this.ctx.fillText("TIME", this.GAME_WIDTH + 50, 125);
                    this.ctx.fillText(displayTime.toString(), this.GAME_WIDTH + 50, 140);

                    // Lives display (as small balloons) - 残機数のみ表示（プレイ中の1機は除く）
                    const remainingLives = Math.max(0, this.lives - 1);
                    for (let i = 0; i < remainingLives; i++) {
                        this.ctx.fillStyle = "#ff4444";
                        this.ctx.beginPath();
                        this.ctx.arc(this.GAME_WIDTH + 20 + i * 8, 155, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }

                    // Update HTML UI elements
                    this.updateHTMLUI();
                }

                /**
                 * HTML UI要素の更新
                 * スコア、ステージ、ライフ数なHTML要素を更新
                 */
                updateHTMLUI() {
                    const scoreElement = document.getElementById("score");
                    const hiScoreElement = document.getElementById("hiscore");
                    const stageElement = document.getElementById("stage");
                    const livesElement = document.getElementById("lives");

                    if (scoreElement) scoreElement.textContent = this.score.toString();
                    if (hiScoreElement) hiScoreElement.textContent = this.hiScore.toString();
                    if (stageElement) stageElement.textContent = this.stage.toString();
                    if (livesElement) livesElement.textContent = this.lives.toString();
                }

                /**
                 * メインゲームループ
                 * フレームごとに呼び出されてゲームの更新と描画を実行
                 */
                gameLoop() {
                    const currentTime = performance.now();
                    const deltaTime = currentTime - this.lastTime;
                    this.lastTime = currentTime;

                    // FPS計算とフレームカウンタの更新
                    if (deltaTime > 0) {
                        this.fps = 1000 / deltaTime;
                    }
                    this.frameCount++;

                    // タイマーの更新
                    this.timer += deltaTime;
                    const currentState = this.stateManager.getState();
                    
                    if (currentState === "PLAYING") {
                        this.stageTimer += deltaTime;
                    } else if (currentState === "RESTART") {
                        this.restartTimer += deltaTime;

                        // 1.5秒後にPLAYING状態に戻る
                        if (this.restartTimer >= 1500) {
                            this.stateManager.setState("PLAYING");
                            console.log("Restart complete - returning to PLAYING state");
                        }
                    } else if (currentState === "STAGE_CLEAR") {
                        this.stageClearTimer += deltaTime;

                        // Transition to next stage after 1 second
                        if (this.stageClearTimer >= 1000) {
                            console.log(
                                `Loading next stage. Current stage: ${this.stage}, Total stages: ${STAGES.length}, Lives: ${this.lives}`
                            );

                            // プレイヤーのライフ数チェック
                            if (this.lives <= 0) {
                                console.log("No lives remaining, going to game over");
                                this.stateManager.setState("GAME_OVER");
                            } else {
                                // 次のステージがあるかチェック
                                if (this.stage <= STAGES.length) {
                                    console.log(
                                        `Loading next stage... Current stage: ${this.stage}, STAGES.length: ${STAGES.length}`
                                    );
                                    this.loadStageData();
                                    this.resetPlayer();
                                    this.resetStageTimer();
                                    this.stateManager.setState("RESTART");
                                    this.restartTimer = 0;
                                    this.isNextStage = true; // 次ステージへの遷移
                                    this.isTimeUp = false;
                                } else {
                                    // All stages completed - cycle back to stage 1
                                    console.log("Congratulations！！ All stages completed, cycling back to stage 1");
                                    this.stage = 1;
                                    this.loadStageData();
                                    this.resetPlayer();
                                    this.resetStageTimer();
                                    this.stateManager.setState("RESTART");
                                    this.restartTimer = 0;
                                    this.isNextStage = true; // 次ステージへの遷移
                                    this.isTimeUp = false;
                                }
                                console.log(`New state: ${this.stateManager.getState()}, Lives: ${this.lives}`);
                            }
                        }

                    }

                    // ゲームロジックの更新（特殊状態以外）
                    this.updateInput();
                    this.handleGameState();

                    // PLAYING状態のみゲームオブジェクトを更新
                    if (this.stateManager.isPlaying()) {
                        this.updatePlayer(deltaTime);

                        // タイマーの更新
                        this.remainingTime -= deltaTime;
                        if (this.remainingTime <= 0) {
                            this.remainingTime = 0;
                            this.onTimeUp();
                        }

                        // 風船の衝突判定（衝突判定が有効な場合のみ）
                        if (this.stateManager.isCollisionDetectionEnabled() && this.checkBalloonCollision()) {
                            console.log("Collision detected in game loop");
                            this.onBalloonHit();
                        }
                    }

                    // Reset input vector for next frame (will be set by analog stick if needed)
                    this.inputVector = { x: 0, y: 0 };

                    // Always update particles for effects
                    this.updateParticles(deltaTime);

                    // Render
                    this.render();

                    // Schedule next frame
                    requestAnimationFrame(() => this.gameLoop());
                }
            }

            // ===== INITIALIZATION =====
            window.addEventListener("load", () => {
                new CrazyBalloon();
            });
        </script>
    </body>
</html>
